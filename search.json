[{"path":"/2025/05/31/Hexo的多机更新/","content":"Hexo的多机更新正如大家所看见的样子，我的个人博客很少有时间更新；更准确的来讲就是我的文章产出是非常稀少的，那么我说明一下，目前我在供稿的公众号平台主要是AIProtein、SDbioinfor以及我自己的AIbioMed日记（就是这么深爱这个学科） 虽然跟新的频率很慢，但是还是有很多有意思的文章可以来更新。那么自己的博客为什么更新的这么慢呢？在看过了《孤独的美食家》之后又再次诱发了我的更新创作的灵感。 那么到底是什么阻挠了我呢？（绝对不是懒） 已有环境Hexo框架的多机更新"},{"title":"Hello World","path":"/2025/04/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"关于打牌日记的一些小思考","path":"/2024/10/06/关于打牌日记的一些小思考/","content":"首先，很遗憾宣布万智牌从2024年2月之后的系列里，就都没有提供中文版的卡包了目前最让人感到难过的是中文版的失去，不过MTGA玩的多了也大概知道什么是什么了。 同时，我这次的「暮悲邸」系列是继「神河：霓朝纪」和「非瑞克西亚：万界归一」比较喜欢的系列，同时一些比较强力相较于8月的「斑隆洛」来说，鹏洛客只有一个（但是还是开出来了嘿嘿），一些新的机制我想在单独找个时间来分享一下。 这次的开盒的结果还是要总结一下的，共计5盒（3盒现开盒，2盒肥盒） AI和万智牌目前我参考过得几个文章都在说明AI并不能很好的理解万智牌，这其中一定是有深意的。这里就简单写一些 关于混色的策略在万智牌中，不单单只有单独一种颜色，纯色和混色都是很常见的组合；尤其是在每次新系列发型时，线下牌店的现开赛中你无法保证自己能够开出来的某个单色牌是可以组成一个完整套牌的，因此混色的选择显得尤为重要。 这里我们只对这些颜色的组合进行解释，具体强弱牌桌上见 纯色白色 White– 大地 – 放逐、清场 蓝色 BlUe – 海洋 – 康、抓牌 黑色 Black – 沼泽 – 杀、掀坟 红色 Red – 山脉 – 打脸、烧 绿色 Green – 森林 – 大怪、爆费 双色蓝白（Azorius）– 俄佐立参议院 – 控制、清场 蓝黑（Dimir）– 底密尔会堂 – 弃牌、抓牌、杀 黑红（Rakdos）– 拉铎司宗派 – 换血 红绿（Gruul）– 古鲁部落 – 傻大个 白绿（Selesnya）– 瑟雷尼亚盟会 – tokens 黑白（Orzhov）– 欧佐夫集团 – 死者苏生 红白（Boros）– 波洛斯军团 – 走脸、All in 红蓝（Izzet）– 伊捷联盟 – 组合技、low 黑绿（Golgari）– 葛加理群落 – 杀不完 蓝绿（Simic）– 析米克联合 – 疯狂加豆 三色临三色班特(Bant) – 绿白蓝 纳雅(Naya) – 红绿白 格利极(Grixis) – 蓝黑红 艾斯波(Esper) – 白蓝黑 勇得(Jund) – 黑红绿 对三色阿布赞(Abzan) – 黑白绿 洁斯凯(Jeskai) – 白蓝红 玛尔都(Mardu) – 黑白红 苏勒台(Sultai) – 蓝黑绿 铁木尔(Temur) – 红绿蓝 四色EDH（指挥官赛制） 五色！！！万界登神 悄咪咪自己又下单了一个补充盒和一个梦魇盒。","tags":["万智牌","人工智能"]},{"title":"简述定向进化","path":"/2024/10/04/简述定向进化/","content":"简述酶的定向进化🦍Machine-learning-guided directed evolution 定向进化是酶工程中最为闪耀的一颗明珠，近些年在合成生物学中大放异彩，同时也和机器学习的发展一起逐步发展壮大。本文将主要介绍定向进化(Directed Evolution)这一技术的发展和机器学习在定向进化中的相关工作。 关键词深度学习｜酶工程｜定向进化 目录 背景介绍 实验流程 构建突变文库 选择和筛选 连续定向进化 相关工作 DeepSequence EVmutation UniRep ECnet 1. 背景介绍1.1 酶和酶催化酶（Enzyme） 的化学本质是具有催化活性的蛋白质（少部分是RNA）其具有一下性质： 经酸碱水解的最终产物是氨基酸，且被蛋白酶水解失活 是具有空间结构的大分子 是两性电解质，在不同pH条件呈现不同的离子状态 不能通过半透膜等胶体性质 酶促反应（Enzyme catalysis）又称为酶促反应或酵素催化作用，指的是由酶作为催化剂进行催化的化学反应。 生物体内的化学反应绝大多数属于酶促反应，酶作为一种生物催化剂在催化一个化学反应时，既具有一般的催化剂的特征，又具有不同于一般催化剂的特殊性。 1.2 酶工程对酶的的开发和利用来说，酶是至关重要的一个生物技术内容。酶工程（Enzyme Engineering）主要研究酶的生产、固化、纯化技术、酶分子结构的修饰和改造以及在食品生物医学界的应用。 酶工程主要分为：化学酶工程 和 生物酶工程 化学酶工程：初级酶工程，酶化学与化学工程技术相结合的产物。即通过对酶的化学修饰或固定化处理，改善酶的性质以提高酶的效率和降低成本，甚至通过化学合成法制造人工酶 生物酶工程：高级酶工程，酶学与现代分子生物学技术相结合的产物。用基因重组技术 生产酶以及对酶基因进行修饰或设计新基因，从而生产性能稳定，具有新的生物活性及催化效率更高的酶。 1.3 定向进化定向进化（Directed Evolution） 是通过试管中模拟达尔文进化的进程，通过随机突变和重组并按照需求加以一定的选择压力，从而选择出具有特定特征的蛋白质。在2018年诺贝尔化学奖颁发Frances H. Arnold以表彰她实现了酶的定向进化这一技术。 2. 实验流程2.1 构建突变文库2.1.1 体外突变法 原位易错PCR（In situ error-prone PCR, Is-epPCR）通过将DNA连接酶的引入，建立了“变性-退火-延伸-连接”的循环PCR，实现了环状质粒的指数级PCR扩增，该方法所用引物为还有与模板治理不同筛选标记的线性双链DNA，可以将模板质粒直接从筛选平板上提取。 **定点饱和突变（sequence saturation mutagenesis)**相比于易错 PCR 较高的随机性，饱和突变的目的性很强，操作也更为精确、简单，但是仍然存在明显的氨基酸偏好性(与易错 PCR 类似)、突变体库过于庞大等问题，因此在一定程度上增加了筛选成本。 合成文库（synthetic library generation）在硅基芯片上应用大规模平行寡核苷酸合成技术，然后进行有效的基因组装，每种突变体均采用计算机模拟设计，并在合成前进行筛选，因此消除了不需要的序列偏倚、提前出现的终止密码子和多余的基序。 2.1.2 体内突变法基因突变体库的另一大类构建方法是体内突变法，即在胞内诱导特定基因的突变，无需进行 基因克隆与转化，很大程度上缩短了定向进化的实验周期。例如： 基于单链DNA重组的多元自动化基因组工程技术 CRISPR-Cas系统介导的重组技术 正交易错复制系统 2.2 选择和筛选2.2.1 平板筛选法平板筛选是一种简单且直接的筛选方法,通常是利用平板培养基上不同重组细胞的表型(生长、水解等)在视觉上产生的区分度,将含有目标突变体的重组细胞筛选出来,缺点是仅适用于突变体库的初筛且通量较低 2.2.2 荧光筛选法荧光筛选法是指针对本身无光学特性的酶反应,通过对底物进行荧光标记,根据由化学键断裂或形成导致的样本荧光信号的改变,来表征突变体的催化活性 2.2.3 质谱法在不需要标记的高通量筛选方法中,质谱法作为一种高灵敏度和高特异性的检测方法,在蛋白质工程中应用极广 2.3 连续定向进化连续进化（phage-assisted continuous evolution, PACE） 由噬菌体辅助。连续进化希望在无人为干预的情况下，能够完成基因突变、蛋白表达、表型选择和筛选的迭代实验。连续定向进化通过缩短每轮进化的时间。 3. 相关工作在预测突变效应的效果，目前小编关注了几个自己用过的模型： DeepSequence EVmutation UniRep ECnet 3.1 DeepSequenceDeepSequence 是一个生成性的、无监督的生物序列潜变量模型，给定一个多重序列比对作为输入，它可以用来预测可获得的突变。通过具有非线性依赖关系的潜在变量模型来获得生物序列中的高阶依赖关系。 3.2 EVmutation即Epistatic model（上位效应模型），一种无监督的概率模型，考虑了所有残基对之间的相互作用（上位效应），因为一个位点的突变可能会受到另外一个位点的影响。 推荐阅读：《神经网络从深度突变扫描数据中学习蛋白质序列-功能关系》 3.3 UniRep仅使用少量功能特征化的训练变体（Low-N）即可实现对序列空间的大规模探索，开发了一种在大型未标记蛋白质序列数据集上进行训练的深度学习模型UniRep。UniRep从头开始，仅从序列开始，就学会了将蛋白质的基本特征（包括生物物理，结构和进化信息）提炼成整体的统计摘要或表示形式。 3.4 ECnet利用进化上下文来预测蛋白质工程的功能适应性Fitness。该算法整合了来自同源序列的局部进化背景与全局进化背景，这些序列明确地对蛋白质的残基-残基互作进行建模，以及编码来自庞大蛋白质序列空间的丰富语义和结构特征。 推荐阅读:《ECNet,学习进化信息指导蛋白质工程》 参考文献[1] Wang W W, Zhang Y C, Liu M J. One-step construction of mutagenesis libraries via in situ error-prone PCR[J]. Microbiology China, 2014, 41(4): 719-724. [2] Luo, Y., Jiang, G., Yu, T., Liu, Y., Vo, L., Ding, H., Su, Y., Qian, W. W., Zhao, H., &amp; Peng, J. (2021). ECNet is an evolutionary context-integrated deep learning framework for protein engineering. Nature Communications, 12(1), Article 1. https://doi.org/10.1038/s41467-021-25976-8 [3] Wang, Y., Xue, P., Cao, M., Yu, T., Lane, S. T., &amp; Zhao, H. (2021). Directed evolution: Methodologies and applications. Chemical Reviews, 121(20), Article 20. https://doi.org/10.1021/acs.chemrev.1c00260 [4] Hopf, T., Ingraham, J., Poelwijk, F. et al. Mutation effects predicted from sequence co-variation. Nat Biotechnol 35, 128–135 (2017). https://doi.org/10.1038/nbt.3769 [5] Riesselman, A.J., Ingraham, J.B. &amp; Marks, D.S. Deep generative models of genetic variation capture the effects of mutations. Nat Methods 15, 816–822 (2018). https://doi.org/10.1038/s41592-018-0138-4 [6] Alley, E.C., Khimulya, G., Biswas, S. et al. Unified rational protein engineering with sequence-based deep representation learning. Nat Methods 16, 1315–1322 (2019). https://doi.org/10.1038/s41592-019-0598-1 [7] Ellis, H. M., Yu, D., DiTizio, T., &amp; Donald L. Court. (2001). High efficiency mutagenesis, repair, and engineering of chromosomal DNA using single-stranded oligonucleotides. Proceedings of the National Academy of Sciences, 98(12), 6742–6746. https://doi.org/10.1073/pnas.121164898 [8] Jakočiūnas, T., Pedersen, L. E., Lis, A. V., Jensen, M. K., &amp; Keasling, J. D. (2018). CasPER, a method for directed evolution in genomic contexts using mutagenesis and CRISPR/Cas9. Metabolic Engineering, 48, 288–296. https://doi.org/https://doi.org/10.1016/j.ymben.2018.07.001 [9] Ravikumar, A., Arzumanyan, G. A., Obadi, M. K. A., Javanpour, A. A., &amp; Liu, C. C. (2018). Scalable, Continuous Evolution of Genes at Mutation Rates above Genomic Error Thresholds. Cell, 175(7), 1946–1957.e13. https://doi.org/10.1016/j.cell.2018.10.021","tags":["Protein"]},{"title":"博客主题迁移小记","path":"/2024/10/01/博客主题迁移小记/","content":"好久不见很长时间没有写过自己的博客了，虽然最近这段时间写过了很久的日记，但是博客的更新似乎少了很多。 那么这段时间之后，我应该会恢复对于博客的更新，那么这次更新我重新启用了一个新的更加符合博客风格的主题，随着这些年大家逐渐开始善用Github Pages去搭建自己的博客，逐渐的越来越多的框架越来越丰富，但是我使用了将近6年的Hexo，虽然没有太搞懂他的逻辑，但是像是基于Hugo或是其他的框架也逐渐越来越丰富。 那么这次更新的话，使用了一个小组件更加丰富，且能够进一步了解node项目的主题，Stellar。这个主题似乎已经更新的很完善了，而且更加符合我对于博客风格的认知。其二其自带的wiki功能能够省下我自己去维护一个单独的wiki项目的大部分时间，我想这也节省了我大部分将notion笔记转移到博客的时间，那么下一步如果有时间的话，我想要去找到一个notion同步到博客的方法。 那么希望自己多多的更新博客吧 祝大家国庆节假期快乐目前logo还是空缺的，有时间要自己设计一个自己的logo，网站就先空着吧"},{"title":"Sphinx快速创建文档","path":"/2023/01/26/Sphinx快速创建文档/","content":"写在前面最近在学一些很新的东西，所以想把这些内容整理整理发出来，那么做成一个Document的形式是一种很有效而且很常见的形式；那么Sphinx这个框架首先就进入到了我的视线。主要，可以很轻松的创建文档，同时他可以在编译过程中输出多种格式，这样的效果是我们最为需要的，同时，其可以部署在Github Page上，相比较于Gitbook的简单的文档形式，Sphinx可以通过引用插件的形式进行更多的个性化操作。 部署环境本地环境：Mac OS 13.0.1 线上部署：Github Page + Sphinx 在Mac环境下，可以用Homebrew快速安装Sphinx # Homebrewbrew install sphinx-doc #pippip install sphinx-doc 创建项目sphinx-quickstart #快速创建项目# 1.设置项目的根目录Enter the root path for documentation.&gt; Root path for the documentation [.]:# 2.是否分离build和source目录（一半选择n）You have two options for placing the build directory for Sphinx output.Either, you use a directory &quot;_build&quot; within the root path, or you separate&quot;source&quot; and &quot;build&quot; directories within the root path.&gt; Separate source and build directories (y/n) [n]:# 3.设置前缀（默认）Inside the root directory, two more directories will be created; &quot;_templates&quot;for custom HTML templates and &quot;_static&quot; for custom stylesheets and other staticfiles. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.&gt; Name prefix for templates and static dir [_]:# 4.输入项目的名称和作者The project name will occur in several places in the built documentation.&gt; Project name: Sphinx-test&gt; Author name(s): test# 5. 输入项目的版本号Sphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for thesoftware. Each version can have multiple releases. For example, forPython the version is something like 2.5 or 3.0, while the release issomething like 2.5.1 or 3.0a1. If you don&#x27;t need this dual structure,just set both to the same value.&gt; Project version []: 1.0.0&gt; Project release [1.0.0]:# 6.文档语言If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]:# 7. 设定文档的后缀The file name suffix for source files. Commonly, this is either &quot;.txt&quot;or &quot;.rst&quot;. Only files with this suffix are considered documents.&gt; Source file suffix [.rst]:# 8.设定首页名称One document is special in that it is considered the top node of the&quot;contents tree&quot;, that is, it is the root of the hierarchical structureof the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;document is a custom template, you can also set this to another filename.&gt; Name of your master document (without suffix) [index]:# 9.创建项目A Makefile and a Windows command file can be generated for you so that youonly have to run e.g. `make html&#x27; instead of invoking sphinx-builddirectly.&gt; Create Makefile? (y/n) [y]: y&gt; Create Windows command file? (y/n) [y]: yCreating file ./conf.py.Creating file ./index.rst,.md.Creating file ./Makefile.Creating file ./make.bat.Finished: An initial directory structure has been created.You should now populate your master file ./index.rst,.md and create other documentationsource files. Use the Makefile to build the docs, like so: make builderwhere &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck. 通过上面的步骤就可以在本地创建一个完整的Sphinx项目 .├── Makefile├── build├── make.bat└── source ├── _static ├── _templates ├── conf.py └── index.rst 整个项目结构如上所， build：用来存放makefile生成的网页文件的目录 source：文档的源代码 conf.py：Sphinx的配置文件 index.rst：主文档 后续配置OK，到这里的话你的Sphinx项目已经创建好了，那么如何去配置这个Sphinx的情况，可以参考文章末尾的几个比较新手的使用手册，我也在一点点的摸索，所以大家一起学习一起交流。 部署到Github Page部署到Github这个步骤对于经常使用Git的用户来说并不是很难，但是如何将一个编译好的静态文档同步上去主要面临以下几个问题： 如何只将一些代码和重要文件上传到Github仓库中去 在已经有一个Github Page的情况下如何去展示多个page页面 Step0 创建Github项目仓库这一步的话我不用多做介绍了吧 Step1 设置同步省略文件# .gitignorebuild/ 这个设置之后，很明显编译后生成的build文件夹，并不会随着Git的同步而一起同步到远端， Step2 创建Github Action任务这一步的话，还是不大清楚工作的具体原理是什么，目前知识感觉就是自己编写好的makefile直接放到线上环境中去执行；但是不晓得GitHub在这么多用户数量的情况下为什么会有这样的操作，这一步骤如果不清楚的话最好还是老老实实的去复制别人的文件去粘贴到自己的项目路径下（因为，我就是这么干的） 这部分的话未来找个具体的时间，可以好好的讲一讲 最后写个小插曲–关于如何在项目中使用Jupyter Notebook这个问题是在写一些可能会用到Jupyter中的代码和可视化结果展示的时候，具体的实现效果的话如图所示 在 conf.py文件中添加插件 extensions = [ &quot;nbsphinx&quot;,] 将你的文件存储到项目根目录下（可以单独再去创建一个新的文件存放这些代码） .. toctree:: :maxdepth: 2 :caption: Contents: notebooks&#x2F;Example 1 参考文章[1] 用Sphinx快速制作文档 [2] Sphinx官方文档 [3] Sphinx使用手册","tags":["Sphinx"]},{"title":"系统生物学整理内容汇总","path":"/2023/01/20/系统生物学整理内容汇总/","content":"写在前面这个生物学这个东西，最近不知道为什么越学越迷离；有很多时候甚至不清楚自己做的是什么，主要的原因可能还是不是生物自家出身，有很多基础的生物学内容几乎就是空白。 还是希望能通过这样的方式，稍稍明白明白自己在干点什么 什么是系统生物学系统生物学（systems biology），是一个使用整体论（而非还原论）的方式， 整合不同学科、层次的信息，以研究、分析、理解（即多组学整合分析）生物系统如何行使功能的学术领域。系统生物学通过研究各个生物系统内部所有组成成分间，各分子层面上的相互关系和相互作用（例如，与细胞信号传送、代谢通路[1]、细胞器、细胞、生理系统与生物等相关的基因和蛋白网络），期望最终能够建立整个系统的可理解模型，以及为有机体绘制完整图谱。系统生物学使用计算机模拟，数学分析的方法来构建复杂生物系统的模型。 系统生物学不同于以往只注意个别的基因和蛋白质的实验生物学，研究所有的基因、所有的蛋白质和组分间的所有相互关系；其目标是：对复杂的生物系统构建计算的数学模型，从总体上预测生物系统的真实性。特别是从2000年开始，这个概念在各种环境下被广泛用于生物学。人类基因组计划是生物学中应用系统思维的一个例子，它导致新的合作的方式来处理在遗传学生物学领域的问题。系统生物学的目标之一是模拟和发现涌现的特性，细胞的，组织的和生物体的特性，作为一个系统，其理论描述只能用系统生物学的技术进行[2]。这些通常涉及代谢网络或细胞信号传送网络[1]。 系统生物学开始于对基因和蛋白质的研究，该研究使用高通量技术来测定某物种在给定条件干涉下基因组和蛋白质组的变化。研究基因组的高通量技术包括用来测定mRNA变化的生物芯片技术。高通量蛋白质组学方法包括质谱，该技术用于鉴定蛋白质，检测蛋白修饰和量化蛋白质表达水平。 上面这段是摘自Wiki 一些哲学思考 系统生物学与合成(synthesis)的观点 系统生物学试图由合成的角度看生物学，合成的观点选择面对子系统不独立的可能性，而希望寻找新的方法来解决子系统间交互作用的问题。就像是研究任何一个科学问题一样，解决这问题的第一个步骤是有系统地收集这些交互作用的信息。在过去采用化约论的观点看问题时，在用一个新的观点诠释问题时，才会注意到过去那些被忽视的信息。佛来明发现抗生素时，并不是因为只有他观察到这现象，而是因为只有他重视这现象。因此能够灵活地由不同的尺度，不同的观点看问题时，才容易有新的发现。 传统生物学假设细胞是一个黑盒子，我们可以加入物质(例如养份或抑制剂)，或制作突变株来扰动这未知的系统，再做实验上的观察。系统生物学在设计实验时，所测量的数值或许与过去所差不多，可是使用巨量分析的技术收集大量数据，而解释数据的观点也不相同，甚至会引入许多生物学者不熟悉的分析方式。这种先收集大量数据，再做理论分析的研究方法是比较有效率的方式，可在同样的时间内由不同的专家“平行”地研究不同的路径。更重要的是这种研究方式，让我们有机会观察到许多路径间的交互作用，这是在针对单一路径做研究时不容易看见的信息，因此才有机会由合成的角度分析生物学。在发展遗传工程学时，曾经淘汰了一批不习惯用这样方式思考的人，也让学习这种思考方式的人有了飞快的进展。系统生物学的观点是否相当于过去遗传工程学对生物学的冲击，不同的人或许有不同的见解，可是可以确认的是它会发现一些过去忽视的现象，而且能与化约的观点互补。或许现在发展系统生物学的时机尚未成熟，可是我们是要创造时势，或是在未来追随时代的潮流，是我们应该思考的问题。 生物信息学是过渡到未来生物学的重要工具 未来的生物学究竟是否会综合化约与合成的观点来建立生物学的理论架构虽然尚不明朗，可以确认的是生物信息学的工具将像遗传工程技术那样的深入到每个生物学实验室。这种新的工具是这两种观点都需要的工具，它不但能被动地节省做分析的人力，也能主动地引入“由信息驱动的生物医学研究”。这种新的研究方式强调由数据中做观察，比较，进而提出假设，再以实验方法做验证。这种利用“信息探采(data mining)”的研究模式，与传统实验生物学的搭配，将使我们能更有效率地发现新的现象，因此生物信息学将使我们能更早地进展到有理论架构的未来生物学。 综合而言，基因体分析等研究为我们累积了巨量的数据，而生物信息学可协助我们利用这些数据加速做新的观察之速率，因此有机会由整体的、合成的角度检视生物学，而建立所谓的系统生物学。未来的生物学很可能透过灵活地、交错地运用化约与合成两种观点，建立起生物学的理论架构，使传统生物学由描述性的科学，转型变成一种分析性的未来生物学。 系统理论和系统思想对于我国知识分子并不陌生。1980年在我国学术界曾经流行过“三论”——系统论、信息论和控制论，其中的“系统论”是指奥地利科学家贝塔朗菲（L. Bertalanffy）在1970年创立的“一般系统论”（general system theory）。尽管贝塔朗菲是以生物学家的身份去思考、研究并提出系统论的，但他的系统论并不仅仅适用于生命科学，而且适用于物理学、心理学、经济学和社会科学等各门学科。如果说过去所谈论的是指在哲学层面上的、普适性强的一般系统论，那么本文所要介绍的系统生物学（systems biology），则是生命科学研究领域的一门新兴学科。 作为人类基因组计划的发起人之一，美国科学家莱诺伊•胡德（Leroy Hood）也是系统生物学的创始人之一。在胡德看来，系统生物学和人类基因组计划有着密切的关系。正是在基因组学、蛋白质组学等新型大科学发展的基础上，孕育了系统生物学。反之，系统生物学的诞生进一步提升了后基因组时代的生命科学研究能力。正如胡德所说，“系统生物学将是21世纪医学和生物学的核心驱动力”[1]。基于这一信念，胡德在1999年年底辞去了美国西雅图市华盛顿大学的教职，与另外两名志同道合的科学家一起创立了世界上第一个系统生物学研究所（Institute for Systems Biology）。随后，系统生物学便逐渐得到了生物学家的认同，也唤起了一大批生物学研究领域以外的专家的关注。2002年3月，美国《科学》周刊登载了系统生物学专集。该专集导论中的第一句话这样写道：“如果对当前流行的、时髦的关键词进行一番分析，那么人们会发现，‘系统’高居在排行榜上。” 什么是系统生物学？ 根据胡德的定义，系统生物学是研究一个生物系统中所有组成成分（基因、mRNA、蛋白质等）的构成，以及在特定条件下这些组分间的相互关系的学科。也就是说，系统生物学不同于以往的实验生物学——仅关心个别的基因和蛋白质，它要研究所有的基因、所有的蛋白质、组分间的所有相互关系。显然，系统生物学是以整体性研究为特征的一种大科学。 系统生物学的基本工作流程有这样四个阶段。首先是对选定的某一生物系统的所有组分进行了解和确定，描绘出该系统的结构，包括基因相互作用网络和代谢途径，以及细胞内和细胞间的作用机理，以此构造出一个初步的系统模型。第二步是系统地改变被研究对象的内部组成成分（如基因突变）或外部生长条件，然后观测在这些情况下系统组分或结构所发生的相应变化，包括基因表达、蛋白质表达和相互作用、代谢途径等的变化，并把得到的有关信息进行整合。第三步是把通过实验得到的数据与根据模型预测的情况进行比较，并对初始模型进行修订。第四阶段是根据修正后的模型的预测或假设，设定和实施新的改变系统状态的实验，重复第二步和第三步，不断地通过实验数据对模型进行修订和精练。系统生物学的目标就是要得到一个理想的模型，使其理论预测能够反映出生物系统的真实性。 系统生物学的灵魂——整合 作为后基因组时代的新秀，系统生物学与基因组学、蛋白质组学等各种“组学”的不同之处在于，它是一种整合型大科学。首先，它要把系统内不同性质的构成要素（基因、mRNA、蛋白质、生物小分子等）整合在一起进行研究。系统生物学研究所的第一篇研究论文，就是整合酵母的基因组分析和蛋白质组分析，研究酵母的代谢网络。由于不同生物分子的研究难度不一样，技术发展程度不一样，目前对它们的研究水平有较大的差距。例如，基因组和基因表达方面的研究已经比较完善，而蛋白质研究就较为困难，至于涉及生物小分子的代谢组分的研究就更不成熟。因此，要真正实现这种整合还有很长的路要走。 对于多细胞生物而言，系统生物学要实现从基因到细胞、到组织、到个体的各个层次的整合。《科学》周刊系统生物学专集中一篇题为“心脏的模型化——从基因到细胞、到整个器官”的论文，很好地体现了这种整合性。我们知道，系统科学的核心思想是：“整体大于部分之和”；系统特性是不同组成部分、不同层次间相互作用而“涌现”的新性质；对组成部分或低层次的分析并不能真正地预测高层次的行为。如何通过研究和整合去发现和理解涌现的系统性质，是系统生物学面临的一个带根本性的挑战。 系统生物学整合性的第三层含义是指研究思路和方法的整合。经典的分子生物学研究是一种垂直型的研究，即采用多种手段研究个别的基因和蛋白质。首先是在DNA水平上寻找特定的基因，然后通过基因突变、基因剔除等手段研究基因的功能；在基因研究的基础上，研究蛋白质的空间结构，蛋白质的修饰以及蛋白质间的相互作用等等。基因组学、蛋白质组学和其他各种“组学”则是水平型研究，即以单一的手段同时研究成千上万基因或蛋白质。而系统生物学的特点，则是要把水平型研究和垂直型研究整合起来，成为一种“三维”的研究。此外，系统生物学还是典型的多学科交叉研究，它需要生命科学、信息科学、数学、计算机科学等各种学科的共同参与。 系统生物学的整合性可以体现在两种不同的策略上。第一种就是胡德和系统生物学研究所采用的方式，选定一个较为简单的系统，如单细胞生物酵母，然后分析尽可能多的构成成分——基因组、转录组、蛋白质组、相互作用组，以揭示整个系统的行为。另外一种策略是吉尔曼（A. G. Gilman）领导的“信号转导联军”采用的，以一个较为复杂的系统（G蛋白介导的和与其相关的细胞信号转导系统）为研究对象，采用尽可能多的研究手段去进行分析。 系统生物学的基础——信息 在前分子生物学时代，生物学家把生命视为具有特殊“活力”的有机体，遵循着无机界不存在的法则进行生命活动。在分子生物学时代，研究者们把生命视为一架精密的机器，由基因和蛋白质根据物理、化学的规律来运转。在后基因组时代，像胡德这种类型的科学家，把生命视为信息的载体，一切特性都可以从信息的流动中得到实现。 胡德提出，应该把生物学视为一门信息科学。这个观点包含有三层意思。首先，生物学研究的核心——基因组，是数字化的（digital）。生物学与所有其他学科，如物理学、化学、地理学，是完全不一样的科学，因为生物学以外的学科都只能通过类比的方式（analog）进行分析。既然生物学研究的核心是数字化的，因此生物学可以被完全破译。从理论上说，我们对生物学的把握应该超过其他任何一门学科。其次，生命的数字化核心表现为两大类型的信息，第一类信息是指编码蛋白质的基因，第二类信息是指控制基因行为的调控网络。显然，由一段DNA序列组成的基因是数字化的。值得强调的是，基因调控网络的信息从本质上说也是数字化的，因为控制基因表达的转录因子结合位点也是核苷酸序列。生物学是信息科学的第三层意思是，生物信息是有等级次序的，而且沿着不同的层次流动。一般说来，生物信息以这样的方向进行流动：DNA→mRNA→蛋白质相互作用网络→细胞→器官→个体→群体。这里要注意的是，每个层次信息都对理解生命系统的运行提供有用的视角。因此，系统生物学的重要任务就是要尽可能地获得每个层次的信息并将它们进行整合。 根据系统论的观点，构成系统的关键不是其组成的物质，而是组成部分的相互作用或部分之间的关系。这些相互作用或者关系，从本质上说就是信息。换一个角度来说，生命是远离平衡态的开放系统，为了维持其有序性，生命系统必须不断地与外部环境交换能量，以抵消其熵增过程。奥地利物理学家薛定谔早在1940年发表的著作《生命是什么？》中就已指出，生命以“负熵流”为食，而“负熵”其实就是信息的另一种表示方法。因此，我们可以这样说，生命系统是一个信息流的过程，系统生物学就是要研究并揭示这种信息的运行规律。 系统生物学的钥匙——干涉 系统生物学一方面要了解生物系统的结构组成，另一方面是要揭示系统的行为方式。相比之下，后一个任务更为重要。也就是说，系统生物学研究的并非一种静态的结构，而是要在人为控制的状态下，揭示出特定的生命系统在不同的条件下和不同的时间里具有什么样的动力学特征。 凡是实验科学都有这样一种特征：人为地设定某种或某些条件去作用于被实验的对象，从而达到实验的目的。这种对实验对象的人为影响就是干涉（perturbation）。传统生物学采用非干涉方法如形态观察或分类研究生物体。20世纪形成的分子生物学等实验生物学的特点就是，科学家可以在实验室内利用各种手段干涉生物学材料，如通过诱导基因突变或修饰蛋白质，由此研究其性质和功能。系统生物学同样也是一门实验性科学，也离不开干涉这一重要的工具。 系统生物学中的干涉有这样一些特点。首先，这些干涉应该是有系统性的。例如人为诱导基因突变，过去大多是随机的；而在进行系统生物学研究时，应该采用的是定向的突变技术。上面所提到的对酵母的系统生物学研究，胡德等人就是把已知的参与果糖代谢的9个基因逐一进行突变，研究在每一个基因突变下的系统变化。果蝇从受精开始到形成成熟个体一共有66个典型的发育阶段，不久前科学家利用基因芯片技术，对每一个发育阶段的基因表达谱进行了系统的研究。这也是一类系统性的干涉方式。其次，系统生物学需要高通量的干涉能力，如高通量的遗传变异。现有技术已经能做到在短时间内，把酵母的全部6000多个基因逐一进行突变。对于较为复杂的多细胞生物，可以通过RNA干涉新技术来实现大规模的基因定向突变。随着研究技术的发展，一定还会有许多新的干涉技术应用于系统生物学。 需要提请人们注意的是，以测定基因组全序列或全部蛋白质组成的基因组研究或蛋白质组研究等“规模型大科学”，并不属于经典的实验科学。这类工作中并不需要干涉，其目标只是把系统的全部元素测定清楚，以便得到一个含有所有信息的数据库。胡德把这种类型的研究称为“发现的科学”（discovery science），而把上述依赖于干涉的实验科学称为“假设驱动的科学”（hypothesis-driven science），因为选择干涉就是在做出假设。系统生物学不同于一般的实验生物学就在于，它既需要“发现的科学”，也需要“假设驱动的科学”。首先要选择一种条件（干涉），然后利用“发现的科学”的方法，对系统在该条件下的所有元素进行测定和分析；在此基础上做出新的假设，然后再利用“发现的科学”研究手段进行新研究。这两种不同研究策略和方法的互动和整合，是系统生物学成功的保证。 系统生物学的另一个特点——对理论的依赖和建立模型的需求。 系统生物学的理想就是要得到一个尽可能接近真正生物系统的理论模型；建模过程贯穿在系统生物学研究的每一个阶段。离开了数学和计算机科学，就不会有系统生物学。也许正是基于这一考虑，科学家把系统生物学分为“湿”的实验部分（实验室内的研究）和“干”的实验部分（计算机模拟和理论分析）。“湿”、“干”实验的完美整合才是真正的系统生物学。 从某种意义上说，系统生物学在中国有很好的基础。我们的传统医学就是把人体视为一个系统，通过测定和改变系统的输入和输出来调节系统的状态。传统科学的缺点在于，它只能进行“黑箱操作”，不能解释系统的内部组成成分和动力学过程。而系统生物学则把生物系统化为“白箱”，不仅要了解系统的结构和功能，而且还要揭示出系统内部各组成成分的相互作用和运行规律。 相关的领域 表型组学 Phenomics 基因组学 表观遗传学 转录组 蛋白质组学 代谢物组学 糖组学 脂类组学 Lipidomics 相互作用组学 Interactomics 代谢组学 Fluxomics 生物组学 Biomics 大大的疑问和困惑 多组学联合分析居然也算是系统生物学的范畴吗？（看来已经做了一段时间了） 开发的那些不知道是什么东西的小玩意","tags":["System Biology"]},{"title":"R获取芯片探针与基因关系","path":"/2022/08/15/R获取芯片探针与基因关系/","content":"将一些比较常见的芯片的包转换Gene_ID 写在前面目前市面上现有的芯片种类有很多，其中常用的芯片并不多 一般在分析数据都需要把探针的ID转换成Gene_ID 目前主要在生信技能树中出现过的芯片数据包，主要是以下几种： GPL Origanism bioc_package 1 GPL32 Mus musculus mgu74a 2 GPL33 Mus musculus mgu74b 3 GPL34 Mus musculus mgu74c 6 GPL74 Homo sapiens hcg110 7 GPL75 Mus musculus mu11ksuba 8 GPL76 Mus musculus mu11ksubb 9 GPL77 Mus musculus mu19ksuba 10 GPL78 Mus musculus mu19ksubb 11 GPL79 Mus musculus mu19ksubc 12 GPL80 Homo sapiens hu6800 13 GPL81 Mus musculus mgu74av2 14 GPL82 Mus musculus mgu74bv2 15 GPL83 Mus musculus mgu74cv2 16 GPL85 Rattus norvegicus rgu34a 17 GPL86 Rattus norvegicus rgu34b 18 GPL87 Rattus norvegicus rgu34c 19 GPL88 Rattus norvegicus rnu34 20 GPL89 Rattus norvegicus rtu34 22 GPL91 Homo sapiens hgu95av2 23 GPL92 Homo sapiens hgu95b 24 GPL93 Homo sapiens hgu95c 25 GPL94 Homo sapiens hgu95d 26 GPL95 Homo sapiens hgu95e 27 GPL96 Homo sapiens hgu133a 28 GPL97 Homo sapiens hgu133b 29 GPL98 Homo sapiens hu35ksuba 30 GPL99 Homo sapiens hu35ksubb 31 GPL100 Homo sapiens hu35ksubc 32 GPL101 Homo sapiens hu35ksubd 36 GPL201 Homo sapiens hgfocus 37 GPL339 Mus musculus moe430a 38 GPL340 Mus musculus mouse4302 39 GPL341 Rattus norvegicus rae230a 40 GPL342 Rattus norvegicus rae230b 41 GPL570 Homo sapiens hgu133plus2 42 GPL571 Homo sapiens hgu133a2 43 GPL886 Homo sapiens hgug4111a 44 GPL887 Homo sapiens hgug4110b 45 GPL1261 Mus musculus mouse430a2 49 GPL1352 Homo sapiens u133x3p 50 GPL1355 Rattus norvegicus rat2302 51 GPL1708 Homo sapiens hgug4112a 54 GPL2891 Homo sapiens h20kcod 55 GPL2898 Rattus norvegicus adme16cod 60 GPL3921 Homo sapiens hthgu133a 63 GPL4191 Homo sapiens h10kcod 64 GPL5689 Homo sapiens hgug4100a 65 GPL6097 Homo sapiens illuminaHumanv1 66 GPL6102 Homo sapiens illuminaHumanv2 67 GPL6244 Homo sapiens hugene10sttranscriptcluster 68 GPL6947 Homo sapiens illuminaHumanv3 69 GPL8300 Homo sapiens hgu95av2 70 GPL8490 Homo sapiens IlluminaHumanMethylation27k 71 GPL10558 Homo sapiens illuminaHumanv4 72 GPL11532 Homo sapiens hugene11sttranscriptcluster 73 GPL13497 Homo sapiens HsAgilentDesign026652 74 GPL13534 Homo sapiens IlluminaHumanMethylation450k 75 GPL13667 Homo sapiens hgu219 76 GPL15380 Homo sapiens GGHumanMethCancerPanelv1 77 GPL15396 Homo sapiens hthgu133b 78 GPL17897 Homo sapiens hthgu133a ​","tags":["Bioinformatics"]},{"title":"【ML】2022年机器学习的状况","path":"/2022/08/10/【ML】2022年机器学习的状况/","content":"在机器学习领域中：无法解释某些模型有用的具体原因","tags":["Machine Learning"]},{"title":"现有GitHub成就系统","path":"/2022/08/02/现有GitHub成就系统/","content":"Github Achievements 个人页面目前已知的成就那么对于一个成就收集爱好者来说，收集过GitHub最近新出的成就徽章会是个很有意思的事情 Title badge Enable Earned by? Pair Extraordinaire ✅ 完成多个作者的合并请求 Quickdraw ✅ 在5分钟内关闭一个issue / pull request（自己的项目也算 ） Starstruck ✅ 创建的一个仓库获得16颗stars Galaxy Brain ✅ 回答别人的 discussion 被接受2次 Pull Shark ✅ 成功合并2次 pull requests YOLO ✅ 不评审直接合并代码 Arctic Code Vault Contributor ❌ 在2020年GitHub代码存储计划中提交代码 Public Sponsor ✅ 成为公众支持计划中的一员 Mars 2020 Contributor ❌ 在2020 Github 火星计划中提交代码 其中Pair Extraordinaire、Starstruck、Galaxy Brain、Pull Shark分别在以下数字中可以获得对应的金银铜三种材质奖牌 10、24、48 128、512、4096 8、16、32 16、128、1024","tags":["github"]},{"title":"VSCode插件开发日记--1环境配置","path":"/2022/01/03/VSCode插件开发日记-1环境配置/","content":"写在前面​ 在插件商店中找了很久，能听歌了，能写知乎了，甚至可以去交代码了。但是在kaggle的比赛中并没有相关的插件，所以开始着手写自己的第一个插件，去适应相关的数据竞赛的环境。 前期准备​ 在VScode的文档页有对插件开发的相关介绍，需要自己的电脑已经安装了Node.js 和 Git ​ 之后运行 npm install -g yo generator-codeyo code? What type of extension do you want to create? New Extension (JavaScript)? What&#39;s the name of your extension? Kaggle-Tools? What&#39;s the identifier of your extension? kaggle-tools? What&#39;s the description of your extension?? Enable JavaScript type checking in &#39;jsconfig.json&#39;? No? Initialize a git repository? Yes? Which package manager to use? npm 之后，进入到编辑器中 ，按F5，会在一个新的本地插件开发窗口打开 ![image-20220103195211834](/Users/l_collection/Library/Application Support/typora-user-images/image-20220103195211834.png) 在运行窗口中 cmd+shift+p 调出命令面板，输入Hello World 右下角弹出相应的信息反馈。 后续开发之后可以尝试改变右下角的消息弹出内容 1. 改变showInformationMessage()中的内容在extension.js文件中（我是以JavaScript格式生成的） 1. 再次运行开发窗口，重复运行一边上述的操作，发现弹出信息发生变化 DebugVScode在插件开发的过程中可以进行断点调试 项目文件夹结构.├── .gitignore &#x2F;&#x2F;配置不需要加入版本管理的文件├── .vscode &#x2F;&#x2F; VS Code的整合│ ├── launch.json│ ├── settings.json│ └── tasks.json├── .vscodeignore &#x2F;&#x2F;配置不需要加入最终发布到拓展中的文件├── README.md├── src &#x2F;&#x2F; 源文件│ └── extension.ts &#x2F;&#x2F; 如果我们使用js来开发拓展，则该文件的后缀为.js├── test &#x2F;&#x2F; test文件夹│ ├── extension.test.ts &#x2F;&#x2F; 如果我们使用js来开发拓展，则该文件的后缀为.js│ └── index.ts &#x2F;&#x2F; 如果我们使用js来开发拓展，则该文件的后缀为.js├── node_modules│ ├── vscode &#x2F;&#x2F; vscode对typescript的语言支持。│ └── typescript &#x2F;&#x2F; TypeScript的编译器├── out &#x2F;&#x2F; 编译之后的输出文件夹(只有TypeScript需要，JS无需)│ ├── src│ | ├── extension.js│ | └── extension.js.map│ └── test│ ├── extension.test.js│ ├── extension.test.js.map│ ├── index.js│ └── index.js.map├── package.json &#x2F;&#x2F; 该拓展的资源配置文件├── tsconfig.json &#x2F;&#x2F; ├── typings &#x2F;&#x2F; 类型定义文件夹│ ├── node.d.ts &#x2F;&#x2F; 和Node.js关联的类型定义│ └── vscode-typings.d.ts &#x2F;&#x2F; 和VS Code关联的类型定义└── vsc-extension-quickstart.md package.json&#123; &quot;name&quot;: &quot;sample&quot;, //插件扩展名称（对应创建项目时候的输入） &quot;displayName&quot;: &quot;sample&quot;, &quot;description&quot;: &quot;blog sample&quot;, //插件扩展的描述（对应创建项目时候的输入） &quot;version&quot;: &quot;0.0.1&quot;, &quot;publisher&quot;: &quot;caipeiyu&quot;, //发布时候的一个名称（对应创建项目时候的输入） &quot;engines&quot;: &#123; &quot;vscode&quot;: &quot;^0.10.10&quot; &#125;, &quot;categories&quot;: [ &quot;Other&quot; ], &quot;activationEvents&quot;: [ //这是我们要理解的地方，是触发插件执行一些代码的配置 &quot;onCommand:extension.sayHello&quot; //这种是通过输入命令来触发执行的 ], &quot;main&quot;: &quot;./out/src/extension&quot;, //这个是配置TypeScript编译成js的输出目录 &quot;contributes&quot;: &#123; &quot;commands&quot;: [&#123; //title 和 command是一个对应关系的 &quot;command&quot;: &quot;extension.sayHello&quot;, //这个是对应上面那个命令触发的，在代码里面也要用到 &quot;title&quot;: &quot;Hello World&quot; //这个是我们在vscode里面输入的命令 &#125;] &#125;, &quot;scripts&quot;: &#123; //是在发布打包，或者其他运行时候，要执行的一些脚本命令 &quot;vscode:prepublish&quot;: &quot;node ./node_modules/vscode/bin/compile&quot;, &quot;compile&quot;: &quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;, &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot; &#125;, &quot;devDependencies&quot;: &#123; //这是开发的依赖包，如果有其他的依赖包，并要打包的话，需要把dev去掉 &quot;typescript&quot;: &quot;^1.8.5&quot;, &quot;vscode&quot;: &quot;^0.11.0&quot; &#125;&#125; extension.ts&#x27;use strict&#x27;;// The module &#x27;vscode&#x27; contains the VS Code extensibility API// Import the module and reference it with the alias vscode in your code belowimport * as vscode from &#x27;vscode&#x27;;// this method is called when your extension is activated// your extension is activated the very first time the command is executedexport function activate(context: vscode.ExtensionContext) &#123; // Use the console to output diagnostic information (console.log) and errors (console.error) // This line of code will only be executed once when your extension is activated console.log(&#x27;Congratulations, your extension &quot;sample&quot; is now active!&#x27;); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand(&#x27;extension.sayHello&#x27;, () =&gt; &#123; //只看这个地方&#x27;extension.sayHello&#x27;和 package.json 里面的 &quot;onCommand:extension.sayHello&quot; 是一个对应关系 // The code you place here will be executed every time your command is executed // Display a message box to the user vscode.window.showInformationMessage(&#x27;Hello World!&#x27;); &#125;); context.subscriptions.push(disposable); &#125; // this method is called when your extension is deactivated export function deactivate() &#123; &#125; 当我们需要多增加一个命令叫做Hello Sample的，需要在package.json的文件中添加相关配置 ...&quot;activationEvents&quot;: [ &quot;onCommand:extension.sayHello&quot;, &quot;onCommand:extension.saySample&quot;],&quot;contributes&quot;: [ &quot;commands&quot;: [&#123; &quot;command&quot;: &quot;extension.sayHello&quot;, &quot;title&quot;: &quot;Hello World&quot; &#125;,&#123; &quot;command&quot;: &quot;extension.saySample&quot;, &quot;title&quot;: &quot;Hello Sample&quot; &#125;]],... 添加完成配置后，在extension.ts文件中注册命令事件 let disposable = vscode.commands.refisterCommand(&#x27;extension.sayHello&#x27;, () =&gt; &#123; vscode.window.showInformationMessage(&#x27;Hello World!&#x27;);&#125;);context.subscriptions.push(dispossable);let saySample = vscode.commands.registerCommand(&#x27;extension.saySample&#x27;,() =&gt; &#123; vscode.windows.showInformationMessage(&#x27;This is a new sample command!&#x27;);&#125;);context.subscriptions.push(saySample); 打包与发布在编写完成插件后，需要将它打包压缩之后才能发布到官网中。 npm install -g vsce 一个打包工具 cd到项目的目录下 vsce public 发布成功后可以在vscode中用 ext install来安装这个插件。这种方法需要去配置一个token，还会过期等巴拉巴拉的问题 正确简便的发布方式vsce packageExecuting prepublish script &#39;node .&#x2F;node_modules&#x2F;vscode&#x2F;bin&#x2F;compile&#39;...Created: &#x2F;sample&#x2F;sample-0.0.1.vsix 执行完成后，在执行一个script &#39;node ./node_moudles/vscode/bin/compile&#39;这个命令是在package.json 然后再配置 &quot;scripts&quot;: &#123; &quot;vscode:prepublish&quot;: &quot;node ./node_modules/vscode/bin/compile&quot;, &quot;compile&quot;: &quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;, &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;&#125;, 执行之后会生成一个sample-0.0.1.vsix，这个就是打包好的插件安装包，直接拖到vscode的窗口上，就会提示安装成功重启vscode，重启之后就能使用相关命令了，在插件的目录下也多了相应的sample的目录","tags":["TypeScript","VScode"]},{"title":"生信--高通量测序分析","path":"/2021/12/25/生信-高通量测序分析/","content":"生物信息学分析应用 高通量测序分析高通量测序，一次性对几百万到十亿条DNA分子进行并行测序，又称为下一代测序技术，其可以对一个物种的转录组和基因组进行深入、细致、全貌的分析，所以又被称为深度测序 主要包括：High-throughput Sequencing , Next Generation Sequencing , Deep Sequencing 高通量测序应用 DNA测序：全基因组de novo测序，基因组重测序，宏基因组测序，人类外显子组捕获测序 RNA测序：转录组测序，microRNA测序，电子表达谱测序 表观基因组研究：ChIP-Seq，DNA甲基化 基因组测序基因组测序是对一个物种的基因组DNA打断后进行高通量测序，根据是否有已知基因组数据主要分为de novo全基因组测序和基因组重测序，De novo基因组测序是对未知基因组序列的物种进行基因组从头测序，利用生物信息学分析手段对序列进行拼接、组装，从而获得该物种的基因组图谱。全基因组重测序是对一直基因组序列的物种进行不同个体的基因组测序，并在此基础上对个体或群体进行差异化分析 Paired-End方法基因组打断后，选择一定长度（200-500bp）的序列链接两端接头进行两头测序。Mate-end建库较为复杂，序列打断后，选取一定长度序列（3-5kb），需先连接生物素，再环化，再打断，生物素富集，连接两端接头进行两端测序。 ​ 基因组测序应用生物信息学分析其结果，主要涵盖以下几个方面： - 数据产出处理：图像识别与Base Calling去除接头序列、检测与去除污染序列等 - 基因组组装：原始数据统计、测序深度分析、组装结果统计等； - 基因组注释：Coding Gene注释、RNA分类注释、重复序列注释等； - 基因功能注释：GO功能分类、Interpro功能分类； - 比较基因组及分子进化分析：SNP/InDel/CNV检测等 宏基因组测序是对某一个特定环境，如肠道、土壤、海水等，其中所有微生物进行基因组测序。通过这种方法可以对该环境中的微生物种类和优势物种进行检测，解释微生物群落多样性、种群结构、进化关系、功能活性、相互协作关系及与环境之间的关系。自然环境中很多微生物无法分离培养，而这种方法并不需要对微生物进行分离培养。宏基因组测序方法有：全基因组的宏基因组测序和16S/18S rRNA宏基因组测序。 全基因组的宏基因组测序​ 通过高通量测序技术，对环境样品的总DNA直接进行全基因组的宏基因组测序，能够实现微生物群落的物种分类研究、群落结构、系统进化、功能注释以及物种间的代谢网络研究，挖掘具有应用价值的基因资源，开发新的微生物活性物质。与传统的Sanger法相比，速度快，性价比高，周期短，单个样品的测序量接近饱和。 ​ 宏基因组测序信息分析主要包括：拼接组装、物种分类组成分析、基因预测和功能注释、生成Profilling table、主成分分析（PCA），筛选与样品分组显著的相关因子，多样品间比较分析等。 16S/18S rRNA宏基因组测序​ 是微生物群落分析和细菌进化研究以及分类研究最常用的靶分子，采用新一代的测序技术，对16S/18S rRNA的可变区进行测序分析，不需要进行克隆筛选，能全面的反映微生物群体的物种组成，真实的物种分布及丰度信息。 ​ 16S/18S rRNA测序信息分析主要包括：物种分类、物种丰度分析、OTU（Operational Taxonomic Units）分析，多样性分析，系统进化分析，多样品间的比较分析等。 人类外显子组捕获测序​ 指全部外显子区域的集合，该区域包括合成蛋白质所需要的重要信息，涵盖了与个体记表型相关的大部分功能性变异。与全基因组重测序相比，外显子组测序只需要对外显子区域的DNA，覆盖度更深，数据准确性更高，更加简便、经济、高效。 ​ 外显子捕获是指用外显子芯片杂交，把基因组外显子序列进行捕获，然后对所捕获的序列进行测序。现在常用外显子芯片有Roche NimbleGen Sequence Capture 2.1M Human Exome Array和Agilent SureSelect Target Enrichment System（Human Exome）。 转录组测序 转录组即特定细胞在某一功能状态下所能转录出来的所有RNA的总和，包括mRNA和非编码RNA(Non-coding RNA)。 第二代测序系统可精确检测单个碱基，并且不受到研究中先验信息的干扰，科研人员能够快速地获得某一物种特定器官或组织在某一状态下几乎所有mRNA转录本序列，从而能够开展：UTRs区域界定、可变剪切研究、低丰度新转录本发现、融合基因鉴定、cSNP（编码序列单核苷酸多态性）研究等。 无参考序列转录组分析内容包括：1 测序数据产量统计，数据成分和质量评估；2 Contig及Scaffold长度分布；3 Unigene的长度分布和功能注释，GO分类，Pathway分析，差异表达分析；4 蛋白功能预测与分类，差异表达基因GO富集和 Pathway富集分析。 有参考序列转录组分析内容包括：1 基本数据统计，比对参考序列；2 序列在基因组上在分布；3 测序深度分析、随机性评估和基因差异表达分析；4 新基因预测，基因可变剪接鉴定和基因融合鉴定等。 电子表达谱测序 电子表达谱测序（Digital Gene Expression, DGE）又称为基因表达标签测序（mRNA tag profiling），又称Tag-SAGE。其原理是通过两种酶切作用对基因中一段长度为21nt的序列标签进行测序。由于其测序只针对表达的基因进行测序，产生的数据量相对较小，是研究基因表达谱的经济而快速的研究手段。是对特定处理条件下的全基因组基因表达谱进行分析，已被广泛用于功能基因组学和医学等研究领域。 电子表达谱分析内容包括：图像识别与原始碱基数据读取，去污染、去接头，标签序列计数统计，基因组比对与统计，基因序列比对获得所表达的基因列表，基因差异表达分析，聚类与表达类型分析，GO基因富集与分类分析，Pathway富集与分类分析，蛋白相互作用网络分析，反义链转录本与新转录本检测等。 小RNA测序 小RNA是指长度在21-31nt的内源性非蛋白质编码RNA，广泛存在于高等和低等生物体内，其对mRNA的转录及转录后水平等生命过程起到调节作用。现已知小RNA可归纳成三类：微RNA (miRNA)，小干扰RNA(siRNA)和与piwi相互作用的RNA(piRNA)。 miRNA长度为2124nt，产生于有典型茎环二级结构的原转录本(pri-miRNA)，在动植物的目标mRNA的降解与抑制方面发挥重要作用。siRNA，长度在1925nt，产生于长双链RNA，同样在动植物的目标mRNA的降解与抑制方面发挥重要作用。piRNA，长度26~31nt，由与其相互作用的Piwi蛋白定义，目前研究表明其在配子形成的过程中起作用。 小RNA测序分析内容包括以下两个主要方面： 基本分析：原始数据读取，去接头、去污染序列，长度分布统计，基因组比对等。 高级分析：Small RNA的分类注释，miRNA / siRNA / piRNA的鉴定，新miRNA预测，差异表达miRNA聚类分析等。 ChIP-Seq​ ChIP-Chromatin Immunoprecipitation染色质免疫共沉淀，是指通过蛋白免疫相互作用，用抗体把和染色质相互作用的蛋白，如组蛋白、转录因子等，沉淀下来，从而所获取与其相结合的DNA序列。ChIP-Seq就是通过高通量测序对ChIP所得到的序列进行测序，从而进行蛋白和DNA相互作用相关研究。 ChIP-Seq分析内容包括： ChIP Sequencing结果与参考基因组序列进行比对。 ChIP Sequencing reads 在全基因组的分布：唯一比对reads 在repeats 区域的分布，唯一比对reads 在各基因功能元件上的分布，唯一比对reads 的全基因组覆盖深度。 全基因组peak 扫描：peak 扫描，peak 长度分布统计，peak 的全基因组覆盖度，peak 在基因功能元件上的分布特征， Peak相关基因分析筛选与GO功能富集分析。 多个样品的差异分析：基于peak 相关基因的差异分析，基于peak 的差异分析。 DNA甲基化测序​ DNA甲基化对机体发育和基因表达有很重要的调控作用，和各种癌症的发生和发展也有很大相关性，所以对基因组DNA甲基化进行研究是一直来的热门课题。通过高通量测序来研究DNA甲基化现在主要有两种方法，一种是MeDIP，是通过与DNA甲基化位点相结合的抗体，进行免疫共沉淀，然后对所得DNA序列进行测序。另一种是Bisulfite Sequencing，是通过Bisulfite处理基因组来区分甲基化位点。 MeDIP-Seq分析内容包括： MeDIP-seq 序列与参考序列的比对。 MeDIP-seq 序列数据在全基因组的分布趋势： MeDIP-seq 测序reads 在全基因组上每条染色体上的分布，MeDIP-seq 测序reads 在全基因组上的覆盖深度，MeDIP-Seq 测序reads 在CG、CHG和CHH位点上的覆盖深度，MeDIP-Seq 测序reads 在不同基因功能元件上的分布，MeDIP-Seq 测序reads 在不同OE含量区域中的分布。 统计MeDIP-seq 序列富集区域（peak）的信息：Peak 扫描，Peak 长度数量及比例分布统计，单个样品Peak 的OE含量分布统计，寻找Peak 相关基因，统计Peak 在不同基因功能元件上的分布。 基于Peak 的多样品间差异分析：分析两个样品间的Peak 相关差异基因，对两个样品间的差异基因进行GO功能富集分析及pathway 功能分析。 Bisulfite Sequencing分析内容包括： Bisulfite-seq序列与参考序列的比对。 深度和覆盖度分析：C碱基有效测序深度的累积分布，不同reads 测序深度下的基因组覆盖度。 计算C碱基的甲基化水平。 全基因组甲基化数据分布趋势分析：甲基化C碱基中CG, CHG 与CHH的分布比例（H=A、C or T），CG、CHG和CHH中的所有C的甲基化水平，各条染色体中CG、CHG和CHH中C的甲基化水平（该项分析目前只用于“人”），统计不同基因区域内CG、CHG和CHH中C的甲基化水平，不同基因元件区域中CG、CHG和CHH中C的甲基化水平，CHG，CHH中甲基化C附近的9bp序列的序列特征分析。 全基因组DNA 甲基化图谱：染色体水平的甲基化C碱基的密度分布（该项分析目前只用于“人”），Scaffold的甲基化C碱基密度分布（该项分析针对物种：非人），不同基因组区域的甲基化分布特征，基因组不同转录元件中的DNA甲基化水平。 差异甲基化区域（DMR）分析。","tags":["Bioinformatics"]},{"title":"生物信息学实践","path":"/2021/11/29/生物信息学实践/","content":"写在前面总体上还是什么都没有的","tags":["Bioinfo-Tools"]},{"title":"数据结构（二）-- 初识数据结构","path":"/2021/09/18/数据结构（二）/","content":"数据结构基本概念数据 对于客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号总称 数据元素 数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理 数据对象 性质相同的数据集合，是数据的一个子集 数据结构 相互之间存在一种或多种特定关系的数据元素的集合 结构 数据元素之间的关系 常见的数据结构： 集合 所有元素同属于同一集合中 线性结构 结构中的数据元素之间存在一个对一个的关系 树形结构 结构中的数据元素之间存在一个对多个的关系 图状结构/网状结构 结构中的数据元素之间存在多个对多个的关系 数据结构的形式定义 一个二元组$$Data_Struct=(D,S)$$D : 数据元素的有限集 S ： D上关系的有限集 物理结构 数据结构在计算机中的表示 （存储结构） 位（bit） 信息的最小单位 元素（结点） 若干位组合起来形成的一个位串表示数据元素 数据域 数据元素由若干数据项组成，位串中对应于各个数据项的子位串 顺序映像 &amp;&amp; 非顺序映像 数据元素之间的关系在计算机中有两种不同的表示方式 顺序存储结构 &amp;&amp; 链式存储结构 顺序结构的特点： 借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系 非顺序结构的特点： 借助指示元素存储地址的指针（pointer）表示数据元素之间的逻辑关系 虚拟存储结构 数据结构在C虚拟处理器中的表示 数据类型 和数据结构密切相关的概念，用来刻画程序操作对象的特征 原子类型 原子类型的值是不可分解的 例如： 基本类型、指针类型和空类型 结构类型 数值是可以分解的，例如 结构体 抽象数据类型 Abstract Data Type 是指一个数学模型以及定义在该模型上的一组操作 原子类型 属于原子类型的变量的值是不可分割的 固定聚合类型 属于改类型的变量，数据 可变聚合类型 构成可变聚合类型的“值”的成分数目不确定","tags":["数据结构"]},{"title":"数据结构（一）-- 序章","path":"/2021/09/13/序章/","content":"关于这门课程数据结构作为计算机专业的基础专业课程，在学习中有着举足轻重的作用；而如果未来有考研的计划的话，这会是一个很重要的课程。 文章结构未来我会跟着课程的进度，对对应章节进行归纳整理出相对应的文章，把握课程的中心思想并为期末复习做好充足准备。","tags":["数据结构"]},{"title":"Github入门教程","path":"/2021/03/09/Github入门教程/","content":"写在前面这又是我开的另一个大坑的内容，这部分主要是想要讲一下GitHub的基本使用方法、一些常用的指令以及一个我正在采用的同步的一个流程。 关于GitHubGitHub是全球最大的同性交流网站，在上面你几乎能找到你想要的一切内容，而且越来越多人和组织加入到开源的大家庭中这是一件好事。我也是很早以前就接触到了开源的世界，大家在一起交流分享知识增进自己的代码水平，让自己不断的成长。 进入社区前你要做好的准备首先就是一个GitHub的账号，当然如今市面上有很多的开源社区都可以选择，技术和实现的过程几乎是一样的，这里我以我最常用的GitHub为例子来个大家讲解。账号可以在GitHub首页直接注册，目前来说裸连的话也是没有问题的。但是有些时候也会抽风，所以最好准备一个梯子以防不时之需。 注册完账号之后便是配置在本地环境，直接在终端中输入以下指令 ssh-keygen -C &quot;email adress&quot; -t rsa 这条指令会在你的用户路径下生成一个./ssh的文件夹，进入之后你会发现有两个文件，id_rsa这个文件是私钥（保存好），另一个id_rsa.pub这个是你的公钥。 之后进入GitHub的个人设置页面中SSH and GPG keys选项中将你的公钥复制进去（是公钥里面的数据，记事本打开即可），完成之后点击add SSH key。 这样你的配置就完成了。 关于指令的用法在本地的环境配置好了以后 常用指令 创建新仓库创建新的文件夹，打开，执行 git init 检出仓库执行语句将他人的仓库克隆到本地 git clone /path/to/repository 如果是远程服务器上的仓库 git clone username@host:/path/to/repository 工作流本地的仓库被GitHub用三部分进行维护，并加以三颗“树”状结构进行维护。 工作目录 是你仓库中实际存储的内容 暂存区（Index） 在你改动工作目录后，将你的操作暂时存储在该区域 HEAD 他指向自己的最后一次操作 添加和提交可以提出更改（将他们添加到暂存区中） git add &lt;filename&gt;git add * 使用指令将实际的更改提交 git commit -m &quot;代码提交信息&quot; 之后你的改动就被提交到了HEAD，但是还没有推送到远程仓库 推送改动执行语句，将你的改动从HEAD中推送到远端仓库 git push origin master 上方语句实例中，将HEAD提交到master分支中，也可提交到其他分支中。 如果没有克隆现有仓库，而且你还想将自己的仓库同步到某个服务器中 git remote add origin &lt;server&gt; 这样就可以将自己的仓库同步上去了 分支在开发的时候是在默认的主支上进行的，你可以通过一定的指令操作同步到其他分支，最后开发结束之后合并在一起。 git checkout -b feature_x //创建一个feature_x的分支，并切换过去git checkout mastr //切换到主分支git branch -d feature_x //将feature_x分支删除git push origin &lt;branch&gt; //除非将分支推送到远程仓库，不然别人无法访问 更新合并更新本地仓库至线上最新改动版本 git pull 以用来在自己的工作目录中 获取(fetch) 并 合并(merge) 远端的改动 如果要合并其他分支到自己当前分支上时，执行 git merge &lt;branch&gt; 在这两种情况下，git都会尝试自动合并改动。有一定的几率会出现 冲突(conflicts) 。这时候需要自己去手动修改某些文件，使得修改完成之后，执行 git add &lt;filename&gt; 将修改的内容标记为合并成功 在合并之前，可以使用 git diff &lt;source_branch&gt;&lt;target_branch&gt; 来看一下修改前后文件的差别在哪里 标签为软件发布创建标签是推荐的，在之前的软件开发过程中，这个理念就有所体现，在SVN中也有。 可以执行以下命令创建一个叫做1.0.0的标签 git tag 1.0.0 1b2e1d63ff 后面的 1b2e1d63ff 是你想提交ID的前十位字符，可以使用 git log 获取提交ID log如果想要了解一个本地仓库的历史记录，可以直接执行 git log 同时也可以添加一些参数，来获取一些自己想要的特定消息，只看某一人的提交 git log --author=bob 一个压缩后的每一条提交记录只占一行的输出： git log --pretty=oneline 或者你想通过ASCII艺术的树形结构来展示所有的分支，每个分支都标示了他的名字和标签 git log --graph --oneline --decorate --all 看看那些文件发生了变化 git log --name-status 这些只是你可以使用的一小部分参数 git log --help 替换本地改动假如操作发生失误，可以使用如下的命令替换掉本地改动 git checkout --&lt;filename&gt; 此命令可以将HEAD中的最新内容替换掉你的工作目录中的文件。已经添加到暂存区的改动以及新文件都不会收到影响。 git fetch origingit reset --hard oringin/master 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你的本地主分支指向它"},{"title":"构建自己的学习环境","path":"/2021/02/13/构建自己的学习环境/","content":"写在前面一直觉得自己的学习环境是十分混乱的，而且学习的目标也是杂乱的，不能很轻易的就看出自己的学习的需求，所以一套合理的学习分工是很有必要的，充分利用自己周未的资源同时也提高自己的学习效率。 环境我的主要的设备是两台笔记本（win+mac环境）加上一台ipad。平时上课和课后的笔记练习等等都是在ipad上完成的，这样大大方便了我的日常学习，在课堂上也可以很快的记录笔记，只是课后的整理并不是很有效率。同时两台电脑的环境可以很好的互相弥补之间的差距，这样的话就算是需要用到win环境的时候也有必要的准备。 如何更加充分的利用自己的ipad 我很担心自己买回来ipad之后是“买前生产力，买后爱奇艺”的这种情况，但是事实并不是这样的，第一个学期下来，我还是坚持的挺好的，比较少的游戏时间和较较长的学习时间。 那么下学期，我想让我的学习更具有效率一点，所以我就要准备好一明确的分工，文献的整理可以在整理好后全平台查询。 一节课开始前我会准备提前先预习下一节课的内容，同时，上课时gn会很好的帮助我记录一节课的内容，其实就算是错过了也有len可以帮助我及时的把黑板的内容记录下来。 暂时想到这么多，下学期开学之后会再更新的","tags":["学习"]},{"title":"Mac环境下安装conda并配置环境","path":"/2021/02/09/Mac环境下安装conda并配置环境/","content":"写在前面 从Linux环境到Windows环境再到如今Mac环境下，python的环境和一些常用环境的配置都挺让人头大的，正巧最近了解到conda环境可以很方便的配置一些常用的环境，以及一些python的包管理也很方便，所以这里我便简单的记录一下我的安装历程，把出现的一些问题罗列一下，希望能帮助到别人不踩相同的坑。 安装Anacoda/Miniconda下载安装根据自己使用的环境的不同，可以在清华大学开源镜像站中找到合适的安装包， 快速链接 在右侧获取下载链接 —–&gt; 常用软件 ——&gt; 选择anaconda/miniconda 两者的主要区别就是，anaconda包含了所有的所需要的内容，而miniconda是一个轻量级的替代，只包含了python和conda从而体积也小了很多。 下载之后在终端中，使用指令bash xxxxx.sh进行安装，按回车后会出现大段的安装说明，直接顺着流程进行就可以顺利安装了 配置conda环境安装完成之后，使用vim ~/.condarc编辑这个文件，便可以修改里面的内容，根据清华大学开源镜像站中的帮助手册，你可以很快的配置完成这一步。 出现的情况每次打开终端自动进入conda的虚拟环境 解决方法： ​ 在.condarc中配置 auto_activate_base 为 false就是关闭 ​ 如果需要打开 conda config –set auto_activate_base true ​ 就可以重新打开 创建虚拟环境使用指令 conda create -n env_name可以创建一个名为env_name的环境 之后进入环境之后再运行 conda install pkg_name安装你所需要的包 出现的问题1. Linking packages … PaddingError: Placeholder of length ‘30’ too short in package qt-5.6.2-vc14_0.% The package must be rebuilt with conda-build &gt; 2.0. 方案： conda update conda ,然后conda update –all 下，可以解决大部分问题 参考阅读：https://blog.csdn.net/xxzhangx/article/details/54379255?locationNum=3&amp;fps=1 常用的指令退出虚拟环境conda deactivate 查看所有虚拟环境conda info -e 查看安装的包conda list 删除虚拟环境conda remove -n env_name --all","tags":["Conda"]},{"title":"青蛙过河题解","path":"/2021/02/01/青蛙过河题解/","content":"我会以图片的形式简单形容一下思路，能够更好的理解。 可以很明显的推导出，整个递归的边界就是tiao(0,y) = y+1 ** ，而左右两岸之间没多一根柱子的话就会使他的数量翻一倍，tiao(x,y) = tiao(x-1,y)*2** 这个公式是推导出来的另一种形式。 #include &lt;bits/stdc++.h&gt;using namespace std;int tiao(int x,int y)&#123; if(x == 0) return y+1; else return 2*tiao(x-1,y);&#125;int main()&#123; int t; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; for(int i=1;i&lt;=t;i++) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); cout &lt;&lt; tiao(x,y) &lt;&lt;endl; &#125; &#125; return 0;&#125; 反思这个题目整体还是以道很简单的递归的题目，同时也是看自己的数学上的推导能力，接下来还是要自己动手多推导，同时也要提高自己的代码实现能力，又很多的题目都是有想法的但是最后还是没有足够的代码基础进行实现。","tags":["SDUT"]},{"path":"/friends/index.html","content":"L_Collection 目前是一个刚毕业的大学牲，目前在从事一些科研工作，对于蛋白质设计、扩散模型和大语言模型等。初次之外，还是一个开元爱好者，也开发过一些小工具提高科研效率。希望大家喜欢～ 文章"},{"path":"/explore/index.html","content":"这都是啥"}]