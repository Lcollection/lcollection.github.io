<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Scikit-plot指北</title>
    <link href="/2023/06/06/Scikit-plot%E6%8C%87%E5%8C%97/"/>
    <url>/2023/06/06/Scikit-plot%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx快速创建文档</title>
    <link href="/2023/01/26/Sphinx%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    <url>/2023/01/26/Sphinx%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在学一些很新的东西，所以想把这些内容整理整理发出来，那么做成一个Document的形式是一种很有效而且很常见的形式；那么Sphinx这个框架首先就进入到了我的视线。主要，可以很轻松的创建文档，同时他可以在编译过程中输出多种格式，这样的效果是我们最为需要的，同时，其可以部署在Github Page上，相比较于Gitbook的简单的文档形式，Sphinx可以通过引用插件的形式进行更多的个性化操作。</p><h1 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h1><p>本地环境：Mac OS 13.0.1 </p><p>线上部署：Github Page + Sphinx</p><p>在Mac环境下，可以用Homebrew快速安装Sphinx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Homebrew</span><br>brew install sphinx-doc <br><br><span class="hljs-meta">#</span><span class="bash">pip</span><br>pip install sphinx-doc<br></code></pre></td></tr></table></figure><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs shell">sphinx-quickstart #快速创建项目<br><br><br><span class="hljs-meta">#</span><span class="bash"> 1.设置项目的根目录</span><br>Enter the root path for documentation.<br><span class="hljs-meta">&gt;</span><span class="bash"> Root path <span class="hljs-keyword">for</span> the documentation [.]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 2.是否分离build和<span class="hljs-built_in">source</span>目录（一半选择n）</span><br>You have two options for placing the build directory for Sphinx output.<br>Either, you use a directory &quot;_build&quot; within the root path, or you separate<br>&quot;source&quot; and &quot;build&quot; directories within the root path.<br><span class="hljs-meta">&gt;</span><span class="bash"> Separate <span class="hljs-built_in">source</span> and build directories (y/n) [n]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 3.设置前缀（默认）</span><br>Inside the root directory, two more directories will be created; &quot;_templates&quot;<br>for custom HTML templates and &quot;_static&quot; for custom stylesheets and other static<br>files. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.<br><span class="hljs-meta">&gt;</span><span class="bash"> Name prefix <span class="hljs-keyword">for</span> templates and static dir [_]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 4.输入项目的名称和作者</span><br>The project name will occur in several places in the built documentation.<br><span class="hljs-meta">&gt;</span><span class="bash"> Project name: Sphinx-test</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Author name(s): <span class="hljs-built_in">test</span></span><br><br><span class="hljs-meta">#</span><span class="bash"> 5. 输入项目的版本号</span><br>Sphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for the<br>software. Each version can have multiple releases. For example, for<br>Python the version is something like 2.5 or 3.0, while the release is<br>something like 2.5.1 or 3.0a1.  If you don&#x27;t need this dual structure,<br>just set both to the same value.<br><span class="hljs-meta">&gt;</span><span class="bash"> Project version []: 1.0.0</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Project release [1.0.0]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 6.文档语言</span><br>If the documents are to be written in a language other than English,<br>you can select a language here by its language code. Sphinx will then<br>translate text that it generates into that language.<br><br>For a list of supported codes, see<br>http://sphinx-doc.org/config.html#confval-language.<br><span class="hljs-meta">&gt;</span><span class="bash"> Project language [en]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 7. 设定文档的后缀</span><br>The file name suffix for source files. Commonly, this is either &quot;.txt&quot;<br>or &quot;.rst&quot;.  Only files with this suffix are considered documents.<br><span class="hljs-meta">&gt;</span><span class="bash"> Source file suffix [.rst]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 8.设定首页名称</span><br>One document is special in that it is considered the top node of the<br>&quot;contents tree&quot;, that is, it is the root of the hierarchical structure<br>of the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;<br>document is a custom template, you can also set this to another filename.<br><span class="hljs-meta">&gt;</span><span class="bash"> Name of your master document (without suffix) [index]:</span><br><br><span class="hljs-meta">#</span><span class="bash"> 9.创建项目</span><br>A Makefile and a Windows command file can be generated for you so that you<br>only have to run e.g. `make html&#x27; instead of invoking sphinx-build<br>directly.<br><span class="hljs-meta">&gt;</span><span class="bash"> Create Makefile? (y/n) [y]: y</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Create Windows <span class="hljs-built_in">command</span> file? (y/n) [y]: y</span><br><br>Creating file ./conf.py.<br>Creating file ./index.rst,.md.<br>Creating file ./Makefile.<br>Creating file ./make.bat.<br><br>Finished: An initial directory structure has been created.<br><br>You should now populate your master file ./index.rst,.md and create other documentation<br>source files. Use the Makefile to build the docs, like so:<br>   make builder<br>where &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck.<br><br></code></pre></td></tr></table></figure><p>通过上面的步骤就可以在本地创建一个完整的Sphinx项目</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">.<br>├── Makefile<br>├── build<br>├── <span class="hljs-keyword">make</span>.bat<br>└── <span class="hljs-keyword">source</span><br>    ├── _static<br>    ├── _templates<br>    ├── <span class="hljs-keyword">conf</span>.<span class="hljs-keyword">py</span><br>    └── <span class="hljs-built_in">index</span>.rst<br></code></pre></td></tr></table></figure><p>整个项目结构如上所，</p><ul><li>build：用来存放makefile生成的网页文件的目录</li><li>source：文档的源代码</li><li>conf.py：Sphinx的配置文件</li><li>index.rst：主文档</li></ul><h1 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h1><p>OK，到这里的话你的Sphinx项目已经创建好了，那么如何去配置这个Sphinx的情况，可以参考文章末尾的几个比较新手的使用手册，我也在一点点的摸索，所以大家一起学习一起交流。</p><h1 id="部署到Github-Page"><a href="#部署到Github-Page" class="headerlink" title="部署到Github Page"></a>部署到Github Page</h1><p>部署到Github这个步骤对于经常使用Git的用户来说并不是很难，但是如何将一个编译好的静态文档同步上去主要面临以下几个问题：</p><ul><li>如何只将一些代码和重要文件上传到Github仓库中去</li><li>在已经有一个Github Page的情况下如何去展示多个page页面</li></ul><h3 id="Step0-创建Github项目仓库"><a href="#Step0-创建Github项目仓库" class="headerlink" title="Step0 创建Github项目仓库"></a>Step0 创建Github项目仓库</h3><p>这一步的话我不用多做介绍了吧</p><h3 id="Step1-设置同步省略文件"><a href="#Step1-设置同步省略文件" class="headerlink" title="Step1 设置同步省略文件"></a>Step1 设置同步省略文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> .gitignore</span><br>build/<br></code></pre></td></tr></table></figure><p>这个设置之后，很明显编译后生成的build文件夹，并不会随着Git的同步而一起同步到远端，</p><h3 id="Step2-创建Github-Action任务"><a href="#Step2-创建Github-Action任务" class="headerlink" title="Step2 创建Github Action任务"></a>Step2 创建Github Action任务</h3><p>这一步的话，还是不大清楚工作的具体原理是什么，目前知识感觉就是自己编写好的makefile直接放到线上环境中去执行；但是不晓得GitHub在这么多用户数量的情况下为什么会有这样的操作，这一步骤如果不清楚的话最好还是老老实实的去复制别人的文件去粘贴到自己的项目路径下（<del>因为，我就是这么干的</del>）</p><p><strong>这部分的话未来找个具体的时间，可以好好的讲一讲</strong></p><h1 id="最后写个小插曲–关于如何在项目中使用Jupyter-Notebook"><a href="#最后写个小插曲–关于如何在项目中使用Jupyter-Notebook" class="headerlink" title="最后写个小插曲–关于如何在项目中使用Jupyter Notebook"></a>最后写个小插曲–关于如何在项目中使用Jupyter Notebook</h1><p>这个问题是在写一些可能会用到Jupyter中的代码和可视化结果展示的时候，具体的实现效果的话如图所示</p><p><img src="https://docs.readthedocs.io/en/stable/_images/example-notebook-rendered.png"></p><ol><li><p>在 conf.py文件中添加插件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">extensions = [<br>    <span class="hljs-string">&quot;nbsphinx&quot;</span>,<br>]<br></code></pre></td></tr></table></figure></li><li><p>将你的文件存储到项目根目录下（可以单独再去创建一个新的文件存放这些代码）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rst">.. toctree::<br>   :maxdepth: 2<br>   :caption: Contents:<br><br>   notebooks&#x2F;Example 1<br></code></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/27544821">用Sphinx快速制作文档</a> </p><p>[2] <a href="https://www.osgeo.cn/sphinx/usage/installation.html">Sphinx官方文档</a></p><p>[3] <a href="https://zh-sphinx-doc.readthedocs.io/en/latest/index.html">Sphinx使用手册</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Sphinx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统生物学整理内容汇总</title>
    <link href="/2023/01/20/%E7%B3%BB%E7%BB%9F%E7%94%9F%E7%89%A9%E5%AD%A6%E6%95%B4%E7%90%86%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2023/01/20/%E7%B3%BB%E7%BB%9F%E7%94%9F%E7%89%A9%E5%AD%A6%E6%95%B4%E7%90%86%E5%86%85%E5%AE%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这个生物学这个东西，最近不知道为什么越学越迷离；有很多时候甚至不清楚自己做的是什么，主要的原因可能还是不是生物自家出身，有很多基础的生物学内容几乎就是空白。</p><p>还是希望能通过这样的方式，稍稍明白明白自己在干点什么</p><h1 id="什么是系统生物学"><a href="#什么是系统生物学" class="headerlink" title="什么是系统生物学"></a>什么是系统生物学</h1><p><strong>系统生物学</strong>（systems biology），是一个使用<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%85%A8%E8%A7%80">整体论</a>（而非<a href="https://zh.wikipedia.org/wiki/%E8%BF%98%E5%8E%9F%E8%AE%BA">还原论</a>）的方式， 整合不同学科、层次的信息，以研究、分析、理解（即<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E7%BB%84%E5%AD%A6&action=edit&redlink=1">多组学</a>整合分析）<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E7%B3%BB%E7%B5%B1">生物系统</a>如何行使功能的<a href="https://zh.wikipedia.org/wiki/%E5%AD%A6%E6%9C%AF">学术</a>领域。系统生物学通过研究各个生物系统内部所有组成成分间，各分子层面上的相互关系和相互作用（例如，与<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%81">细胞信号传送</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E8%AC%9D%E9%80%9A%E8%B7%AF">代谢通路</a>[<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E7%94%9F%E7%89%A9%E5%AD%A6#cite_note-pmid21570668-1">1]</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E%E5%99%A8">细胞器</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E">细胞</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%94%9F%E7%90%86%E7%B3%BB%E7%BB%9F&action=edit&redlink=1">生理系统</a>与<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9">生物</a>等相关的<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E5%9B%A0">基因</a>和<a href="https://zh.wikipedia.org/wiki/%E8%9B%8B%E7%99%BD">蛋白</a>网络），期望最终能够建立整个系统的可理解模型，以及为有机体绘制完整图谱。系统生物学使用<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E6%8B%9F">计算机模拟</a>，数学分析的方法来构建复杂<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E7%B3%BB%E7%B5%B1">生物系统</a>的模型。</p><p>系统生物学不同于以往只注意个别的基因和蛋白质的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%9E%E9%AA%8C%E7%94%9F%E7%89%A9%E5%AD%A6&action=edit&redlink=1">实验生物学</a>，研究所有的基因、所有的蛋白质和组分间的所有相互关系；其目标是：对复杂的生物系统构建计算的数学模型，从总体上预测生物系统的真实性。特别是从2000年开始，这个概念在各种环境下被广泛用于生物学。<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E7%B1%BB%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%AE%A1%E5%88%92">人类基因组计划</a>是生物学中应用<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E7%A7%91%E5%AD%A6">系统思维</a>的一个例子，它导致新的合作的方式来处理在遗传学生物学领域的问题。系统生物学的目标之一是模拟和发现<a href="https://zh.wikipedia.org/wiki/%E6%B6%8C%E7%8E%B0">涌现的特性</a>，细胞的，组织的和生物体的特性，作为一个系统，其理论描述只能用系统生物学的技术进行[<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E7%94%9F%E7%89%A9%E5%AD%A6#cite_note-2">2]</a>。这些通常涉及<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E8%B0%A2%E7%BD%91%E7%BB%9C">代谢网络</a>或<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%81">细胞信号传送</a>网络[<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E7%94%9F%E7%89%A9%E5%AD%A6#cite_note-pmid21570668-1">1]</a>。</p><p>系统生物学开始于对基因和<a href="https://zh.wikipedia.org/wiki/%E8%9B%8B%E7%99%BD%E8%B4%A8">蛋白质</a>的研究，该研究使用<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9A%E9%87%8F%E5%9F%BA%E5%9B%A0%E5%85%8B%E9%9A%86%E6%8A%80%E6%9C%AF">高通量技术</a>来测定某物种在给定条件干涉下<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E5%9B%A0%E7%BB%84">基因组</a>和<a href="https://zh.wikipedia.org/wiki/%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%84">蛋白质组</a>的变化。研究基因组的高通量技术包括用来测定<a href="https://zh.wikipedia.org/wiki/MRNA">mRNA</a>变化的<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E6%99%B6%E7%89%87">生物芯片</a>技术。高通量<a href="https://zh.wikipedia.org/wiki/%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%84%E5%AD%A6">蛋白质组学</a>方法包括<a href="https://zh.wikipedia.org/wiki/%E8%B4%A8%E8%B0%B1">质谱</a>，该技术用于鉴定蛋白质，检测蛋白修饰和量化蛋白质表达水平。</p><p>上面这段是摘自Wiki</p><h1 id="一些哲学思考"><a href="#一些哲学思考" class="headerlink" title="一些哲学思考"></a>一些哲学思考</h1><ol><li>系统生物学与合成(synthesis)的观点 </li></ol><p>系统生物学试图由合成的角度看生物学，合成的观点选择面对子系统不独立的可能性，而希望寻找新的方法来解决子系统间交互作用的问题。就像是研究任何一个科学问题一样，解决这问题的第一个步骤是有系统地收集这些交互作用的信息。在过去采用化约论的观点看问题时，在用一个新的观点诠释问题时，才会注意到过去那些被忽视的信息。佛来明发现抗生素时，并不是因为只有他观察到这现象，而是因为只有他重视这现象。因此能够灵活地由不同的尺度，不同的观点看问题时，才容易有新的发现。 </p><p>传统生物学假设细胞是一个黑盒子，我们可以加入物质(例如养份或抑制剂)，或制作突变株来扰动这未知的系统，再做实验上的观察。系统生物学在设计实验时，所测量的数值或许与过去所差不多，可是使用巨量分析的技术收集大量数据，而解释数据的观点也不相同，甚至会引入许多生物学者不熟悉的分析方式。这种先收集大量数据，再做理论分析的研究方法是比较有效率的方式，可在同样的时间内由不同的专家“平行”地研究不同的路径。更重要的是这种研究方式，让我们有机会观察到许多路径间的交互作用，这是在针对单一路径做研究时不容易看见的信息，因此才有机会由合成的角度分析生物学。在发展遗传工程学时，曾经淘汰了一批不习惯用这样方式思考的人，也让学习这种思考方式的人有了飞快的进展。系统生物学的观点是否相当于过去遗传工程学对生物学的冲击，不同的人或许有不同的见解，可是可以确认的是它会发现一些过去忽视的现象，而且能与化约的观点互补。或许现在发展系统生物学的时机尚未成熟，可是我们是要创造时势，或是在未来追随时代的潮流，是我们应该思考的问题。 </p><ol start="2"><li>生物信息学是过渡到未来生物学的重要工具 </li></ol><p>未来的生物学究竟是否会综合化约与合成的观点来建立生物学的理论架构虽然尚不明朗，可以确认的是生物信息学的工具将像遗传工程技术那样的深入到每个生物学实验室。这种新的工具是这两种观点都需要的工具，它不但能被动地节省做分析的人力，也能主动地引入“由信息驱动的生物医学研究”。这种新的研究方式强调由数据中做观察，比较，进而提出假设，再以实验方法做验证。这种利用“信息探采(data mining)”的研究模式，与传统实验生物学的搭配，将使我们能更有效率地发现新的现象，因此生物信息学将使我们能更早地进展到有理论架构的未来生物学。 </p><p>综合而言，基因体分析等研究为我们累积了巨量的数据，而生物信息学可协助我们利用这些数据加速做新的观察之速率，因此有机会由整体的、合成的角度检视生物学，而建立所谓的系统生物学。未来的生物学很可能透过灵活地、交错地运用化约与合成两种观点，建立起生物学的理论架构，使传统生物学由描述性的科学，转型变成一种分析性的未来生物学。</p><p>系统理论和系统思想对于我国知识分子并不陌生。1980年在我国学术界曾经流行过“三论”——系统论、信息论和控制论，其中的“系统论”是指奥地利科学家贝塔朗菲（L. Bertalanffy）在1970年创立的“一般系统论”（general system theory）。尽管贝塔朗菲是以生物学家的身份去思考、研究并提出系统论的，但他的系统论并不仅仅适用于生命科学，而且适用于物理学、心理学、经济学和社会科学等各门学科。如果说过去所谈论的是指在哲学层面上的、普适性强的一般系统论，那么本文所要介绍的系统生物学（systems biology），则是生命科学研究领域的一门新兴学科。</p><p>作为人类基因组计划的发起人之一，美国科学家莱诺伊•胡德（Leroy Hood）也是系统生物学的创始人之一。在胡德看来，系统生物学和人类基因组计划有着密切的关系。正是在基因组学、蛋白质组学等新型大科学发展的基础上，孕育了系统生物学。反之，系统生物学的诞生进一步提升了后基因组时代的生命科学研究能力。正如胡德所说，“系统生物学将是21世纪医学和生物学的核心驱动力”[1]。基于这一信念，胡德在1999年年底辞去了美国西雅图市华盛顿大学的教职，与另外两名志同道合的科学家一起创立了世界上第一个系统生物学研究所（Institute for Systems Biology）。随后，系统生物学便逐渐得到了生物学家的认同，也唤起了一大批生物学研究领域以外的专家的关注。2002年3月，美国《科学》周刊登载了系统生物学专集。该专集导论中的第一句话这样写道：“如果对当前流行的、时髦的关键词进行一番分析，那么人们会发现，‘系统’高居在排行榜上。”</p><ol start="3"><li>什么是系统生物学？</li></ol><p>根据胡德的定义，系统生物学是研究一个生物系统中所有组成成分（基因、mRNA、蛋白质等）的构成，以及在特定条件下这些组分间的相互关系的学科。也就是说，系统生物学不同于以往的实验生物学——仅关心个别的基因和蛋白质，它要研究所有的基因、所有的蛋白质、组分间的所有相互关系。显然，系统生物学是以整体性研究为特征的一种大科学。</p><p>系统生物学的基本工作流程有这样四个阶段。首先是对选定的某一生物系统的所有组分进行了解和确定，描绘出该系统的结构，包括基因相互作用网络和代谢途径，以及细胞内和细胞间的作用机理，以此构造出一个初步的系统模型。第二步是系统地改变被研究对象的内部组成成分（如基因突变）或外部生长条件，然后观测在这些情况下系统组分或结构所发生的相应变化，包括基因表达、蛋白质表达和相互作用、代谢途径等的变化，并把得到的有关信息进行整合。第三步是把通过实验得到的数据与根据模型预测的情况进行比较，并对初始模型进行修订。第四阶段是根据修正后的模型的预测或假设，设定和实施新的改变系统状态的实验，重复第二步和第三步，不断地通过实验数据对模型进行修订和精练。系统生物学的目标就是要得到一个理想的模型，使其理论预测能够反映出生物系统的真实性。</p><ol start="4"><li>系统生物学的灵魂——整合</li></ol><p>作为后基因组时代的新秀，系统生物学与基因组学、蛋白质组学等各种“组学”的不同之处在于，它是一种整合型大科学。首先，它要把系统内不同性质的构成要素（基因、mRNA、蛋白质、生物小分子等）整合在一起进行研究。系统生物学研究所的第一篇研究论文，就是整合酵母的基因组分析和蛋白质组分析，研究酵母的代谢网络。由于不同生物分子的研究难度不一样，技术发展程度不一样，目前对它们的研究水平有较大的差距。例如，基因组和基因表达方面的研究已经比较完善，而蛋白质研究就较为困难，至于涉及生物小分子的代谢组分的研究就更不成熟。因此，要真正实现这种整合还有很长的路要走。</p><p>对于多细胞生物而言，系统生物学要实现从基因到细胞、到组织、到个体的各个层次的整合。《科学》周刊系统生物学专集中一篇题为“心脏的模型化——从基因到细胞、到整个器官”的论文，很好地体现了这种整合性。我们知道，系统科学的核心思想是：“整体大于部分之和”；系统特性是不同组成部分、不同层次间相互作用而“涌现”的新性质；对组成部分或低层次的分析并不能真正地预测高层次的行为。如何通过研究和整合去发现和理解涌现的系统性质，是系统生物学面临的一个带根本性的挑战。</p><p>系统生物学整合性的第三层含义是指研究思路和方法的整合。经典的分子生物学研究是一种垂直型的研究，即采用多种手段研究个别的基因和蛋白质。首先是在DNA水平上寻找特定的基因，然后通过基因突变、基因剔除等手段研究基因的功能；在基因研究的基础上，研究蛋白质的空间结构，蛋白质的修饰以及蛋白质间的相互作用等等。基因组学、蛋白质组学和其他各种“组学”则是水平型研究，即以单一的手段同时研究成千上万基因或蛋白质。而系统生物学的特点，则是要把水平型研究和垂直型研究整合起来，成为一种“三维”的研究。此外，系统生物学还是典型的多学科交叉研究，它需要生命科学、信息科学、数学、计算机科学等各种学科的共同参与。</p><p>系统生物学的整合性可以体现在两种不同的策略上。第一种就是胡德和系统生物学研究所采用的方式，选定一个较为简单的系统，如单细胞生物酵母，然后分析尽可能多的构成成分——基因组、转录组、蛋白质组、相互作用组，以揭示整个系统的行为。另外一种策略是吉尔曼（A. G. Gilman）领导的“信号转导联军”采用的，以一个较为复杂的系统（G蛋白介导的和与其相关的细胞信号转导系统）为研究对象，采用尽可能多的研究手段去进行分析。</p><ol start="5"><li>系统生物学的基础——信息</li></ol><p>在前分子生物学时代，生物学家把生命视为具有特殊“活力”的有机体，遵循着无机界不存在的法则进行生命活动。在分子生物学时代，研究者们把生命视为一架精密的机器，由基因和蛋白质根据物理、化学的规律来运转。在后基因组时代，像胡德这种类型的科学家，把生命视为信息的载体，一切特性都可以从信息的流动中得到实现。</p><p>胡德提出，应该把生物学视为一门信息科学。这个观点包含有三层意思。首先，生物学研究的核心——基因组，是数字化的（digital）。生物学与所有其他学科，如物理学、化学、地理学，是完全不一样的科学，因为生物学以外的学科都只能通过类比的方式（analog）进行分析。既然生物学研究的核心是数字化的，因此生物学可以被完全破译。从理论上说，我们对生物学的把握应该超过其他任何一门学科。其次，生命的数字化核心表现为两大类型的信息，第一类信息是指编码蛋白质的基因，第二类信息是指控制基因行为的调控网络。显然，由一段DNA序列组成的基因是数字化的。值得强调的是，基因调控网络的信息从本质上说也是数字化的，因为控制基因表达的转录因子结合位点也是核苷酸序列。生物学是信息科学的第三层意思是，生物信息是有等级次序的，而且沿着不同的层次流动。一般说来，生物信息以这样的方向进行流动：DNA→mRNA→蛋白质相互作用网络→细胞→器官→个体→群体。这里要注意的是，每个层次信息都对理解生命系统的运行提供有用的视角。因此，系统生物学的重要任务就是要尽可能地获得每个层次的信息并将它们进行整合。</p><p>根据系统论的观点，构成系统的关键不是其组成的物质，而是组成部分的相互作用或部分之间的关系。这些相互作用或者关系，从本质上说就是信息。换一个角度来说，生命是远离平衡态的开放系统，为了维持其有序性，生命系统必须不断地与外部环境交换能量，以抵消其熵增过程。奥地利物理学家薛定谔早在1940年发表的著作《生命是什么？》中就已指出，生命以“负熵流”为食，而“负熵”其实就是信息的另一种表示方法。因此，我们可以这样说，生命系统是一个信息流的过程，系统生物学就是要研究并揭示这种信息的运行规律。</p><ol start="6"><li>系统生物学的钥匙——干涉</li></ol><p>系统生物学一方面要了解生物系统的结构组成，另一方面是要揭示系统的行为方式。相比之下，后一个任务更为重要。也就是说，系统生物学研究的并非一种静态的结构，而是要在人为控制的状态下，揭示出特定的生命系统在不同的条件下和不同的时间里具有什么样的动力学特征。</p><p>凡是实验科学都有这样一种特征：人为地设定某种或某些条件去作用于被实验的对象，从而达到实验的目的。这种对实验对象的人为影响就是干涉（perturbation）。传统生物学采用非干涉方法如形态观察或分类研究生物体。20世纪形成的分子生物学等实验生物学的特点就是，科学家可以在实验室内利用各种手段干涉生物学材料，如通过诱导基因突变或修饰蛋白质，由此研究其性质和功能。系统生物学同样也是一门实验性科学，也离不开干涉这一重要的工具。</p><p>系统生物学中的干涉有这样一些特点。首先，这些干涉应该是有系统性的。例如人为诱导基因突变，过去大多是随机的；而在进行系统生物学研究时，应该采用的是定向的突变技术。上面所提到的对酵母的系统生物学研究，胡德等人就是把已知的参与果糖代谢的9个基因逐一进行突变，研究在每一个基因突变下的系统变化。果蝇从受精开始到形成成熟个体一共有66个典型的发育阶段，不久前科学家利用基因芯片技术，对每一个发育阶段的基因表达谱进行了系统的研究。这也是一类系统性的干涉方式。其次，系统生物学需要高通量的干涉能力，如高通量的遗传变异。现有技术已经能做到在短时间内，把酵母的全部6000多个基因逐一进行突变。对于较为复杂的多细胞生物，可以通过RNA干涉新技术来实现大规模的基因定向突变。随着研究技术的发展，一定还会有许多新的干涉技术应用于系统生物学。</p><p>需要提请人们注意的是，以测定基因组全序列或全部蛋白质组成的基因组研究或蛋白质组研究等“规模型大科学”，并不属于经典的实验科学。这类工作中并不需要干涉，其目标只是把系统的全部元素测定清楚，以便得到一个含有所有信息的数据库。胡德把这种类型的研究称为“发现的科学”（discovery science），而把上述依赖于干涉的实验科学称为“假设驱动的科学”（hypothesis-driven science），因为选择干涉就是在做出假设。系统生物学不同于一般的实验生物学就在于，它既需要“发现的科学”，也需要“假设驱动的科学”。首先要选择一种条件（干涉），然后利用“发现的科学”的方法，对系统在该条件下的所有元素进行测定和分析；在此基础上做出新的假设，然后再利用“发现的科学”研究手段进行新研究。这两种不同研究策略和方法的互动和整合，是系统生物学成功的保证。</p><ol start="7"><li>系统生物学的另一个特点——对理论的依赖和建立模型的需求。</li></ol><p>系统生物学的理想就是要得到一个尽可能接近真正生物系统的理论模型；建模过程贯穿在系统生物学研究的每一个阶段。离开了数学和计算机科学，就不会有系统生物学。也许正是基于这一考虑，科学家把系统生物学分为“湿”的实验部分（实验室内的研究）和“干”的实验部分（计算机模拟和理论分析）。“湿”、“干”实验的完美整合才是真正的系统生物学。</p><p>从某种意义上说，系统生物学在中国有很好的基础。我们的传统医学就是把人体视为一个系统，通过测定和改变系统的输入和输出来调节系统的状态。传统科学的缺点在于，它只能进行“黑箱操作”，不能解释系统的内部组成成分和动力学过程。而系统生物学则把生物系统化为“白箱”，不仅要了解系统的结构和功能，而且还要揭示出系统内部各组成成分的相互作用和运行规律。</p><h1 id="相关的领域"><a href="#相关的领域" class="headerlink" title="相关的领域"></a>相关的领域</h1><ul><li>表型组学            Phenomics</li><li>基因组学           </li><li>表观遗传学</li><li>转录组</li><li>蛋白质组学</li><li>代谢物组学</li><li>糖组学</li><li>脂类组学            Lipidomics</li><li>相互作用组学    Interactomics</li><li>代谢组学            Fluxomics</li><li>生物组学            Biomics</li></ul><h1 id="大大的疑问和困惑"><a href="#大大的疑问和困惑" class="headerlink" title="大大的疑问和困惑"></a>大大的疑问和困惑</h1><ul><li>多组学联合分析居然也算是系统生物学的范畴吗？（看来已经做了一段时间了）</li><li>开发的那些不知道是什么东西的小玩意</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>System Biology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ML】2022年机器学习的状况</title>
    <link href="/2022/08/10/%E3%80%90ML%E3%80%912022%E5%B9%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%8A%B6%E5%86%B5/"/>
    <url>/2022/08/10/%E3%80%90ML%E3%80%912022%E5%B9%B4%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%8A%B6%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="在机器学习领域中：无法解释某些模型有用的具体原因"><a href="#在机器学习领域中：无法解释某些模型有用的具体原因" class="headerlink" title="在机器学习领域中：无法解释某些模型有用的具体原因"></a>在机器学习领域中：无法解释某些模型有用的具体原因</h2><p><img src="https://www.aidancooper.co.uk/content/images/size/w960/2021/12/utility-vs-understanding-17.png" alt="Utility vs Understanding: the State of Machine Learning Entering 2022"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现有GitHub成就系统</title>
    <link href="/2022/08/02/%E7%8E%B0%E6%9C%89GitHub%E6%88%90%E5%B0%B1%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/08/02/%E7%8E%B0%E6%9C%89GitHub%E6%88%90%E5%B0%B1%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-Achievements-个人页面目前已知的成就"><a href="#Github-Achievements-个人页面目前已知的成就" class="headerlink" title="Github Achievements 个人页面目前已知的成就"></a>Github Achievements 个人页面目前已知的成就</h1><p>那么对于一个成就收集爱好者来说，收集过GitHub最近新出的成就徽章会是个很有意思的事情</p><a id="more"></a><table><thead><tr><th align="center">Title</th><th align="center">badge</th><th align="center">Enable</th><th align="center">Earned by?</th></tr></thead><tbody><tr><td align="center">Pair Extraordinaire</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/pair-extraordinaire-default.png" alt="pair-extraordinaire-default" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">完成多个作者的合并请求</td></tr><tr><td align="center">Quickdraw</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/quickdraw-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">在5分钟内关闭一个issue / pull request<br />（自己的项目也算 ）</td></tr><tr><td align="center">Starstruck</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/starstruck-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">创建的一个仓库获得16颗stars</td></tr><tr><td align="center">Galaxy Brain</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/galaxy-brain-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">回答别人的 discussion 被接受2次</td></tr><tr><td align="center">Pull Shark</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/pull-shark-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">成功合并2次 pull requests</td></tr><tr><td align="center">YOLO</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/yolo-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">不评审直接合并代码</td></tr><tr><td align="center">Arctic Code Vault Contributor</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/arctic-code-vault-contributor-default.png" style="zoom:33%;" /></td><td align="center">❌</td><td align="center">在2020年GitHub代码存储计划中提交代码</td></tr><tr><td align="center">Public Sponsor</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/public-sponsor-default.png" style="zoom:33%;" /></td><td align="center">✅</td><td align="center">成为公众支持计划中的一员</td></tr><tr><td align="center">Mars 2020 Contributor</td><td align="center"><img src="/Users/l_collection/GitHub/github-profile-achievements/images/mars-2020-contributor-default.png" style="zoom:33%;" /></td><td align="center">❌</td><td align="center">在2020 Github 火星计划中提交代码</td></tr></tbody></table><p>其中<strong>Pair Extraordinaire</strong>、<strong>Starstruck</strong>、<strong>Galaxy Brain</strong>、<strong>Pull Shark</strong>分别在以下数字中可以获得对应的金银铜三种材质奖牌 </p><ul><li>10、24、48</li><li>128、512、4096</li><li>8、16、32</li><li>16、128、1024</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode插件开发日记--1环境配置</title>
    <link href="/2022/01/03/VSCode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/01/03/VSCode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​    在插件商店中找了很久，能听歌了，能写知乎了，甚至可以去交代码了。但是在kaggle的比赛中并没有相关的插件，所以开始着手写自己的第一个插件，去适应相关的数据竞赛的环境。</p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>​    在VScode的文档页有对插件开发的相关介绍，需要自己的电脑已经安装了Node.js 和 Git</p><p>​    之后运行</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">npm install -g yo generator-code<br><br>yo code<br><br>? What type <span class="hljs-keyword">of</span> extension <span class="hljs-keyword">do</span> you want <span class="hljs-keyword">to</span> create? <span class="hljs-built_in">New</span> Extension (JavaScript)<br>? What<span class="hljs-comment">&#x27;s the name of your extension? Kaggle-Tools</span><br>? What<span class="hljs-comment">&#x27;s the identifier of your extension? kaggle-tools</span><br>? What<span class="hljs-comment">&#x27;s the description of your extension?</span><br>? Enable JavaScript type checking <span class="hljs-keyword">in</span> <span class="hljs-comment">&#x27;jsconfig.json&#x27;? No</span><br>? Initialize a git repository? Yes<br>? Which package manager <span class="hljs-keyword">to</span> use? npm<br></code></pre></td></tr></table></figure><p>之后，进入到编辑器中 ，按F5，会在一个新的本地插件开发窗口打开</p><p>![image-20220103195211834](/Users/l_collection/Library/Application Support/typora-user-images/image-20220103195211834.png)</p><p>在运行窗口中 <code>cmd+shift+p</code> 调出命令面板，输入Hello World 右下角弹出相应的信息反馈。</p><h2 id="后续开发"><a href="#后续开发" class="headerlink" title="后续开发"></a>后续开发</h2><p>之后可以尝试改变右下角的消息弹出内容</p><pre><code>1. 改变showInformationMessage()中的内容在extension.js文件中（我是以JavaScript格式生成的）1. 再次运行开发窗口，重复运行一边上述的操作，发现弹出信息发生变化</code></pre><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>VScode在插件开发的过程中可以进行断点调试</p><h2 id="项目文件夹结构"><a href="#项目文件夹结构" class="headerlink" title="项目文件夹结构"></a>项目文件夹结构</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<br>├── .gitignore                  <span class="hljs-regexp">//</span>配置不需要加入版本管理的文件<br>├── .vscode                     <span class="hljs-regexp">//</span> VS Code的整合<br>│   ├── launch.json<br>│   ├── settings.json<br>│   └── tasks.json<br>├── .vscodeignore                <span class="hljs-regexp">//</span>配置不需要加入最终发布到拓展中的文件<br>├── README.md<br>├── src                         <span class="hljs-regexp">//</span> 源文件<br>│   └── extension.ts            <span class="hljs-regexp">//</span> 如果我们使用js来开发拓展，则该文件的后缀为.js<br>├── test                        <span class="hljs-regexp">//</span> test文件夹<br>│   ├── extension.test.ts       <span class="hljs-regexp">//</span> 如果我们使用js来开发拓展，则该文件的后缀为.js<br>│   └── index.ts                <span class="hljs-regexp">//</span> 如果我们使用js来开发拓展，则该文件的后缀为.js<br>├── node_modules<br>│   ├── vscode                  <span class="hljs-regexp">//</span> vscode对typescript的语言支持。<br>│   └── typescript              <span class="hljs-regexp">//</span> TypeScript的编译器<br>├── out                         <span class="hljs-regexp">//</span> 编译之后的输出文件夹(只有TypeScript需要，JS无需)<br>│   ├── src<br>│   |   ├── extension.js<br>│   |   └── extension.js.map<br>│   └── test<br>│       ├── extension.test.js<br>│       ├── extension.test.js.map<br>│       ├── index.js<br>│       └── index.js.map<br>├── package.json                <span class="hljs-regexp">//</span> 该拓展的资源配置文件<br>├── tsconfig.json               <span class="hljs-regexp">//</span> <br>├── typings                     <span class="hljs-regexp">//</span> 类型定义文件夹<br>│   ├── node.d.ts               <span class="hljs-regexp">//</span> 和Node.js关联的类型定义<br>│   └── vscode-typings.d.ts     <span class="hljs-regexp">//</span> 和VS Code关联的类型定义<br>└── vsc-extension-quickstart.md <br></code></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br> <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;sample&quot;</span>,              <span class="hljs-comment">//插件扩展名称（对应创建项目时候的输入）</span><br> <span class="hljs-attr">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;sample&quot;</span>,<br> <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;blog sample&quot;</span>,  <span class="hljs-comment">//插件扩展的描述（对应创建项目时候的输入）</span><br> <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.1&quot;</span>,<br> <span class="hljs-attr">&quot;publisher&quot;</span>: <span class="hljs-string">&quot;caipeiyu&quot;</span>,       <span class="hljs-comment">//发布时候的一个名称（对应创建项目时候的输入）</span><br> <span class="hljs-attr">&quot;engines&quot;</span>: &#123;<br>     <span class="hljs-attr">&quot;vscode&quot;</span>: <span class="hljs-string">&quot;^0.10.10&quot;</span><br> &#125;,<br> <span class="hljs-attr">&quot;categories&quot;</span>: [<br>     <span class="hljs-string">&quot;Other&quot;</span><br> ],<br> <span class="hljs-attr">&quot;activationEvents&quot;</span>: [          <span class="hljs-comment">//这是我们要理解的地方，是触发插件执行一些代码的配置</span><br>     <span class="hljs-string">&quot;onCommand:extension.sayHello&quot;</span> <span class="hljs-comment">//这种是通过输入命令来触发执行的</span><br> ],<br> <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./out/src/extension&quot;</span>,  <span class="hljs-comment">//这个是配置TypeScript编译成js的输出目录</span><br> <span class="hljs-attr">&quot;contributes&quot;</span>: &#123;<br>     <span class="hljs-attr">&quot;commands&quot;</span>: [&#123;             <span class="hljs-comment">//title 和 command是一个对应关系的</span><br>         <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;extension.sayHello&quot;</span>, <span class="hljs-comment">//这个是对应上面那个命令触发的，在代码里面也要用到</span><br>         <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>   <span class="hljs-comment">//这个是我们在vscode里面输入的命令</span><br>     &#125;]<br> &#125;,<br> <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;                     <span class="hljs-comment">//是在发布打包，或者其他运行时候，要执行的一些脚本命令</span><br>     <span class="hljs-attr">&quot;vscode:prepublish&quot;</span>: <span class="hljs-string">&quot;node ./node_modules/vscode/bin/compile&quot;</span>,<br>     <span class="hljs-attr">&quot;compile&quot;</span>: <span class="hljs-string">&quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;</span>,<br>     <span class="hljs-attr">&quot;postinstall&quot;</span>: <span class="hljs-string">&quot;node ./node_modules/vscode/bin/install&quot;</span><br> &#125;,<br> <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;           <span class="hljs-comment">//这是开发的依赖包，如果有其他的依赖包，并要打包的话，需要把dev去掉</span><br>     <span class="hljs-attr">&quot;typescript&quot;</span>: <span class="hljs-string">&quot;^1.8.5&quot;</span>,<br>     <span class="hljs-attr">&quot;vscode&quot;</span>: <span class="hljs-string">&quot;^0.11.0&quot;</span><br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="extension-ts"><a href="#extension-ts" class="headerlink" title="extension.ts"></a>extension.ts</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-comment">// The module &#x27;vscode&#x27; contains the VS Code extensibility API</span><br><span class="hljs-comment">// Import the module and reference it with the alias vscode in your code below</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> vscode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vscode&#x27;</span>;<br><br><span class="hljs-comment">// this method is called when your extension is activated</span><br><span class="hljs-comment">// your extension is activated the very first time the command is executed</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activate</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>) </span>&#123;<br><br>    <span class="hljs-comment">// Use the console to output diagnostic information (console.log) and errors (console.error)</span><br>    <span class="hljs-comment">// This line of code will only be executed once when your extension is activated</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Congratulations, your extension &quot;sample&quot; is now active!&#x27;</span>);<br><br>    <span class="hljs-comment">// The command has been defined in the package.json file</span><br>    <span class="hljs-comment">// Now provide the implementation of the command with  registerCommand</span><br>    <span class="hljs-comment">// The commandId parameter must match the command field in package.json</span><br>    <span class="hljs-keyword">let</span> disposable = vscode.commands.registerCommand(<span class="hljs-string">&#x27;extension.sayHello&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//只看这个地方&#x27;extension.sayHello&#x27;和 package.json 里面的 &quot;onCommand:extension.sayHello&quot; 是一个对应关系</span><br>        <span class="hljs-comment">// The code you place here will be executed every time your command is executed</span><br><br>        <span class="hljs-comment">// Display a message box to the user</span><br>        vscode.window.showInformationMessage(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>    &#125;);<br><br>    context.subscriptions.push(disposable);<br>    &#125;<br><br>    <span class="hljs-comment">// this method is called when your extension is deactivated</span><br>    <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deactivate</span>(<span class="hljs-params"></span>) </span>&#123;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>当我们需要多增加一个命令叫做Hello Sample的，需要在package.json的文件中添加相关配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>&quot;activationEvents&quot;: [<br>&quot;onCommand:extension.sayHello&quot;,<br><span class="hljs-string">&quot;onCommand:extension.saySample&quot;</span><br>],<br>&quot;contributes&quot;: [<br>&quot;commands&quot;: [&#123;<br>&quot;command&quot;: &quot;extension.sayHello&quot;,<br>&quot;title&quot;: &quot;Hello World&quot;<br>&#125;,&#123;<br>&quot;command&quot;: &quot;extension.saySample&quot;,<br>&quot;title&quot;: &quot;Hello Sample&quot;<br>&#125;]<br>],<br>...<br></code></pre></td></tr></table></figure><p>添加完成配置后，在extension.ts文件中注册命令事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> disposable = vscode.commands.refisterCommand(<span class="hljs-string">&#x27;extension.sayHello&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>vscode.window.showInformationMessage(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br><br>context.subscriptions.push(dispossable);<br><br><span class="hljs-keyword">let</span> saySample = vscode.commands.registerCommand(<span class="hljs-string">&#x27;extension.saySample&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>vscode.windows.showInformationMessage(<span class="hljs-string">&#x27;This is a new sample command!&#x27;</span>);<br>&#125;);<br>context.subscriptions.push(saySample);<br></code></pre></td></tr></table></figure><h2 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h2><p>在编写完成插件后，需要将它打包压缩之后才能发布到官网中。</p><p><code>npm install -g vsce</code> 一个打包工具</p><p>cd到项目的目录下 </p><p><code>vsce public</code></p><p>发布成功后可以在vscode中用 <code>ext install</code>来安装这个插件。这种方法需要去配置一个token，还会过期等巴拉巴拉的问题</p><h3 id="正确简便的发布方式"><a href="#正确简便的发布方式" class="headerlink" title="正确简便的发布方式"></a>正确简便的发布方式</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">vsce package<br><br>Executing prepublish script &#x27;<span class="hljs-keyword">node</span> <span class="hljs-title">./node_modules</span>/vscode/bin/compile&#x27;...<br><br>Created: /sample/sample-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>.vsix<br></code></pre></td></tr></table></figure><p>执行完成后，在执行一个<code>script &#39;node ./node_moudles/vscode/bin/compile&#39;</code>这个命令是在<code>package.json</code></p><p>然后再配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>    &quot;vscode:prepublish&quot;: &quot;node ./node_modules/vscode/bin/compile&quot;,<br>    &quot;compile&quot;: &quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;,<br>    &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><p>执行之后会生成一个sample-0.0.1.vsix，这个就是打包好的插件安装包，直接拖到vscode的窗口上，就会提示安装成功重启vscode，重启之后就能使用相关命令了，在插件的目录下也多了相应的sample的目录</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>VScode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生信--高通量测序分析</title>
    <link href="/2021/12/25/%E7%94%9F%E4%BF%A1-%E9%AB%98%E9%80%9A%E9%87%8F%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <url>/2021/12/25/%E7%94%9F%E4%BF%A1-%E9%AB%98%E9%80%9A%E9%87%8F%E6%B5%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>生物信息学分析应用</p><a id="more"></a><h2 id="高通量测序分析"><a href="#高通量测序分析" class="headerlink" title="高通量测序分析"></a>高通量测序分析</h2><p>高通量测序，一次性对几百万到十亿条DNA分子进行并行测序，又称为下一代测序技术，其可以对一个物种的转录组和基因组进行深入、细致、全貌的分析，所以又被称为<strong>深度测序</strong></p><p>主要包括：High-throughput Sequencing , Next Generation Sequencing , Deep Sequencing</p><h2 id="高通量测序应用"><a href="#高通量测序应用" class="headerlink" title="高通量测序应用"></a>高通量测序应用</h2><ul><li>DNA测序：全基因组de novo测序，基因组重测序，宏基因组测序，人类外显子组捕获测序</li><li>RNA测序：转录组测序，microRNA测序，电子表达谱测序</li><li>表观基因组研究：ChIP-Seq，DNA甲基化</li></ul><h2 id="基因组测序"><a href="#基因组测序" class="headerlink" title="基因组测序"></a>基因组测序</h2><p>基因组测序是对一个物种的基因组DNA打断后进行高通量测序，根据是否有已知基因组数据主要分为de novo全基因组测序和基因组重测序，De novo基因组测序是对未知基因组序列的物种进行基因组从头测序，利用生物信息学分析手段对序列进行拼接、组装，从而获得该物种的基因组图谱。全基因组重测序是对一直基因组序列的物种进行不同个体的基因组测序，并在此基础上对个体或群体进行差异化分析</p><h3 id="Paired-End方法"><a href="#Paired-End方法" class="headerlink" title="Paired-End方法"></a>Paired-End方法</h3><p>基因组打断后，选择一定长度（200-500bp）的序列链接两端接头进行两头测序。Mate-end建库较为复杂，序列打断后，选取一定长度序列（3-5kb），需先连接生物素，再环化，再打断，生物素富集，连接两端接头进行两端测序。</p><p>​    基因组测序应用生物信息学分析其结果，主要涵盖以下几个方面：</p><pre><code> - 数据产出处理：图像识别与Base Calling去除接头序列、检测与去除污染序列等 - 基因组组装：原始数据统计、测序深度分析、组装结果统计等； - 基因组注释：Coding Gene注释、RNA分类注释、重复序列注释等； - 基因功能注释：GO功能分类、Interpro功能分类； - 比较基因组及分子进化分析：SNP/InDel/CNV检测等</code></pre><h2 id="宏基因组测序"><a href="#宏基因组测序" class="headerlink" title="宏基因组测序"></a>宏基因组测序</h2><p>是对某一个特定环境，如肠道、土壤、海水等，其中所有微生物进行基因组测序。通过这种方法可以对该环境中的微生物种类和优势物种进行检测，解释微生物群落多样性、种群结构、进化关系、功能活性、相互协作关系及与环境之间的关系。自然环境中很多微生物无法分离培养，而这种方法并不需要对微生物进行分离培养。宏基因组测序方法有：全基因组的宏基因组测序和16S/18S rRNA宏基因组测序。</p><h3 id="全基因组的宏基因组测序"><a href="#全基因组的宏基因组测序" class="headerlink" title="全基因组的宏基因组测序"></a>全基因组的宏基因组测序</h3><p>​    通过高通量测序技术，对环境样品的总DNA直接进行全基因组的宏基因组测序，能够实现微生物群落的物种分类研究、群落结构、系统进化、功能注释以及物种间的代谢网络研究，挖掘具有应用价值的基因资源，开发新的微生物活性物质。与传统的Sanger法相比，速度快，性价比高，周期短，单个样品的测序量接近饱和。</p><p>​    宏基因组测序信息分析主要包括：拼接组装、物种分类组成分析、基因预测和功能注释、生成Profilling table、主成分分析（PCA），筛选与样品分组显著的相关因子，多样品间比较分析等。</p><h3 id="16S-18S-rRNA宏基因组测序"><a href="#16S-18S-rRNA宏基因组测序" class="headerlink" title="16S/18S rRNA宏基因组测序"></a>16S/18S rRNA宏基因组测序</h3><p>​    是微生物群落分析和细菌进化研究以及分类研究最常用的靶分子，采用新一代的测序技术，对16S/18S rRNA的可变区进行测序分析，不需要进行克隆筛选，能全面的反映微生物群体的物种组成，真实的物种分布及丰度信息。</p><p>​    16S/18S rRNA测序信息分析主要包括：物种分类、物种丰度分析、OTU（Operational Taxonomic Units）分析，多样性分析，系统进化分析，多样品间的比较分析等。</p><h2 id="人类外显子组捕获测序"><a href="#人类外显子组捕获测序" class="headerlink" title="人类外显子组捕获测序"></a>人类外显子组捕获测序</h2><p>​    指全部外显子区域的集合，该区域包括合成蛋白质所需要的重要信息，涵盖了与个体记表型相关的大部分功能性变异。与全基因组重测序相比，外显子组测序只需要对外显子区域的DNA，覆盖度更深，数据准确性更高，更加简便、经济、高效。</p><p>​    外显子捕获是指用外显子芯片杂交，把基因组外显子序列进行捕获，然后对所捕获的序列进行测序。现在常用外显子芯片有Roche NimbleGen Sequence Capture 2.1M Human Exome Array和Agilent SureSelect Target Enrichment System（Human Exome）。</p><h2 id="转录组测序"><a href="#转录组测序" class="headerlink" title="转录组测序"></a>转录组测序</h2><p>   转录组即特定细胞在某一功能状态下所能转录出来的所有RNA的总和，包括mRNA和非编码RNA(Non-coding RNA)。</p><p>   第二代测序系统可精确检测单个碱基，并且不受到研究中先验信息的干扰，科研人员能够快速地获得某一物种特定器官或组织在某一状态下几乎所有mRNA转录本序列，从而能够开展：UTRs区域界定、可变剪切研究、低丰度新转录本发现、融合基因鉴定、cSNP（编码序列单核苷酸多态性）研究等。<br>   无参考序列转录组分析内容包括：1 测序数据产量统计，数据成分和质量评估；2 Contig及Scaffold长度分布；3 Unigene的长度分布和功能注释，GO分类，Pathway分析，差异表达分析；4 蛋白功能预测与分类，差异表达基因GO富集和 Pathway富集分析。</p><p>   有参考序列转录组分析内容包括：1 基本数据统计，比对参考序列；2 序列在基因组上在分布；3 测序深度分析、随机性评估和基因差异表达分析；4 新基因预测，基因可变剪接鉴定和基因融合鉴定等。</p><h2 id="电子表达谱测序"><a href="#电子表达谱测序" class="headerlink" title="电子表达谱测序"></a>电子表达谱测序</h2><p>   电子表达谱测序（Digital Gene Expression, DGE）又称为基因表达标签测序（mRNA tag profiling），又称Tag-SAGE。其原理是通过两种酶切作用对基因中一段长度为21nt的序列标签进行测序。由于其测序只针对表达的基因进行测序，产生的数据量相对较小，是研究基因表达谱的经济而快速的研究手段。是对特定处理条件下的全基因组基因表达谱进行分析，已被广泛用于功能基因组学和医学等研究领域。</p><p>   电子表达谱分析内容包括：图像识别与原始碱基数据读取，去污染、去接头，标签序列计数统计，基因组比对与统计，基因序列比对获得所表达的基因列表，基因差异表达分析，聚类与表达类型分析，GO基因富集与分类分析，Pathway富集与分类分析，蛋白相互作用网络分析，反义链转录本与新转录本检测等。</p><h2 id="小RNA测序"><a href="#小RNA测序" class="headerlink" title="小RNA测序"></a>小RNA测序</h2><p>   小RNA是指长度在21-31nt的内源性非蛋白质编码RNA，广泛存在于高等和低等生物体内，其对mRNA的转录及转录后水平等生命过程起到调节作用。现已知小RNA可归纳成三类：微RNA (miRNA)，小干扰RNA(siRNA)和与piwi相互作用的RNA(piRNA)。</p><p>   miRNA长度为21<del>24nt，产生于有典型茎环二级结构的原转录本(pri-miRNA)，在动植物的目标mRNA的降解与抑制方面发挥重要作用。siRNA，长度在19</del>25nt，产生于长双链RNA，同样在动植物的目标mRNA的降解与抑制方面发挥重要作用。piRNA，长度26~31nt，由与其相互作用的Piwi蛋白定义，目前研究表明其在配子形成的过程中起作用。</p><h3 id="小RNA测序分析内容包括以下两个主要方面："><a href="#小RNA测序分析内容包括以下两个主要方面：" class="headerlink" title="小RNA测序分析内容包括以下两个主要方面："></a>小RNA测序分析内容包括以下两个主要方面：</h3><ul><li><p>基本分析：原始数据读取，去接头、去污染序列，长度分布统计，基因组比对等。</p></li><li><p>高级分析：Small RNA的分类注释，miRNA / siRNA / piRNA的鉴定，新miRNA预测，差异表达miRNA聚类分析等。</p></li></ul><h2 id="ChIP-Seq"><a href="#ChIP-Seq" class="headerlink" title="ChIP-Seq"></a>ChIP-Seq</h2><p>​    ChIP-Chromatin Immunoprecipitation染色质免疫共沉淀，是指通过蛋白免疫相互作用，用抗体把和染色质相互作用的蛋白，如组蛋白、转录因子等，沉淀下来，从而所获取与其相结合的DNA序列。ChIP-Seq就是通过高通量测序对ChIP所得到的序列进行测序，从而进行蛋白和DNA相互作用相关研究。</p><h3 id="ChIP-Seq分析内容包括："><a href="#ChIP-Seq分析内容包括：" class="headerlink" title="ChIP-Seq分析内容包括："></a>ChIP-Seq分析内容包括：</h3><ul><li><p>ChIP Sequencing结果与参考基因组序列进行比对。</p></li><li><p>ChIP Sequencing reads 在全基因组的分布：唯一比对reads 在repeats 区域的分布，唯一比对reads 在各基因功能元件上的分布，唯一比对reads 的全基因组覆盖深度。</p></li><li><p>全基因组peak 扫描：peak 扫描，peak 长度分布统计，peak 的全基因组覆盖度，peak 在基因功能元件上的分布特征，</p></li><li><p>Peak相关基因分析筛选与GO功能富集分析。</p></li><li><p>多个样品的差异分析：基于peak 相关基因的差异分析，基于peak 的差异分析。</p></li></ul><h2 id="DNA甲基化测序"><a href="#DNA甲基化测序" class="headerlink" title="DNA甲基化测序"></a>DNA甲基化测序</h2><p>​    DNA甲基化对机体发育和基因表达有很重要的调控作用，和各种癌症的发生和发展也有很大相关性，所以对基因组DNA甲基化进行研究是一直来的热门课题。通过高通量测序来研究DNA甲基化现在主要有两种方法，一种是MeDIP，是通过与DNA甲基化位点相结合的抗体，进行免疫共沉淀，然后对所得DNA序列进行测序。另一种是Bisulfite Sequencing，是通过Bisulfite处理基因组来区分甲基化位点。</p><h3 id="MeDIP-Seq分析内容包括："><a href="#MeDIP-Seq分析内容包括：" class="headerlink" title="MeDIP-Seq分析内容包括："></a>MeDIP-Seq分析内容包括：</h3><ul><li><p>MeDIP-seq 序列与参考序列的比对。</p></li><li><p>MeDIP-seq 序列数据在全基因组的分布趋势： MeDIP-seq 测序reads 在全基因组上每条染色体上的分布，MeDIP-seq 测序reads 在全基因组上的覆盖深度，MeDIP-Seq 测序reads 在CG、CHG和CHH位点上的覆盖深度，MeDIP-Seq 测序reads 在不同基因功能元件上的分布，MeDIP-Seq 测序reads 在不同OE含量区域中的分布。</p></li><li><p>统计MeDIP-seq 序列富集区域（peak）的信息：Peak 扫描，Peak 长度数量及比例分布统计，单个样品Peak 的OE含量分布统计，寻找Peak 相关基因，统计Peak 在不同基因功能元件上的分布。</p></li><li><p>基于Peak 的多样品间差异分析：分析两个样品间的Peak 相关差异基因，对两个样品间的差异基因进行GO功能富集分析及pathway 功能分析。</p></li></ul><h3 id="Bisulfite-Sequencing分析内容包括："><a href="#Bisulfite-Sequencing分析内容包括：" class="headerlink" title="Bisulfite Sequencing分析内容包括："></a>Bisulfite Sequencing分析内容包括：</h3><ul><li><p>Bisulfite-seq序列与参考序列的比对。</p></li><li><p>深度和覆盖度分析：C碱基有效测序深度的累积分布，不同reads 测序深度下的基因组覆盖度。</p></li><li><p> 计算C碱基的甲基化水平。</p></li><li><p> 全基因组甲基化数据分布趋势分析：甲基化C碱基中CG, CHG 与CHH的分布比例（H=A、C or T），CG、CHG和CHH中的所有C的甲基化水平，各条染色体中CG、CHG和CHH中C的甲基化水平（该项分析目前只用于“人”），统计不同基因区域内CG、CHG和CHH中C的甲基化水平，不同基因元件区域中CG、CHG和CHH中C的甲基化水平，CHG，CHH中甲基化C附近的9bp序列的序列特征分析。</p></li><li><p>全基因组DNA 甲基化图谱：染色体水平的甲基化C碱基的密度分布（该项分析目前只用于“人”），Scaffold的甲基化C碱基密度分布（该项分析针对物种：非人），不同基因组区域的甲基化分布特征，基因组不同转录元件中的DNA甲基化水平。</p></li><li><p>差异甲基化区域（DMR）分析。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Bioinformatics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生物信息学实践</title>
    <link href="/2021/11/29/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AE%9E%E8%B7%B5/"/>
    <url>/2021/11/29/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>总体上还是什么都没有的</p>]]></content>
    
    
    
    <tags>
      
      <tag>Bioinfo-Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构（二）-- 初识数据结构</title>
    <link href="/2021/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><p><strong>数据</strong> 对于客观事物的符号表示，所有能输入到计算机中并被计算机程序处理的符号总称</p><p><strong>数据元素</strong> 数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理</p><a id="more"></a><p><strong>数据对象</strong> 性质相同的数据集合，是数据的一个子集</p><p><strong>数据结构</strong> 相互之间存在一种或多种特定关系的数据元素的集合</p><p><strong>结构</strong> 数据元素之间的关系 </p><p>常见的数据结构： </p><ul><li>集合    所有元素同属于同一集合中</li><li>线性结构    结构中的数据元素之间存在一个对一个的关系</li><li>树形结构    结构中的数据元素之间存在一个对多个的关系</li><li>图状结构/网状结构    结构中的数据元素之间存在多个对多个的关系</li></ul><p><strong>数据结构的形式定义</strong> 一个二元组<br>$$<br>Data_Struct=(D,S)<br>$$<br>D : 数据元素的有限集             S ： D上关系的有限集</p><p><strong>物理结构</strong> 数据结构在计算机中的表示 （存储结构）</p><p><strong>位（bit）</strong> 信息的最小单位</p><p><strong>元素（结点）</strong> 若干位组合起来形成的一个位串表示数据元素</p><p><strong>数据域</strong> 数据元素由若干数据项组成，位串中对应于各个数据项的子位串</p><p><strong>顺序映像 &amp;&amp; 非顺序映像</strong> 数据元素之间的关系在计算机中有两种不同的表示方式</p><p><strong>顺序存储结构 &amp;&amp; 链式存储结构</strong> </p><ol><li>顺序结构的特点： 借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系</li><li>非顺序结构的特点： 借助指示元素存储地址的指针（pointer）表示数据元素之间的逻辑关系</li></ol><p><strong>虚拟存储结构</strong> 数据结构在C虚拟处理器中的表示</p><p><strong>数据类型</strong> 和数据结构密切相关的概念，用来刻画程序操作对象的特征 </p><p><strong>原子类型</strong> 原子类型的值是不可分解的    例如： 基本类型、指针类型和空类型</p><p><strong>结构类型</strong> 数值是可以分解的，例如 结构体 </p><p><strong>抽象数据类型 Abstract Data Type</strong> 是指一个数学模型以及定义在该模型上的一组操作</p><ul><li>原子类型    属于原子类型的变量的值是不可分割的</li><li>固定聚合类型    属于改类型的变量，数据</li><li>可变聚合类型    构成可变聚合类型的“值”的成分数目不确定</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构（一）-- 序章</title>
    <link href="/2021/09/13/%E5%BA%8F%E7%AB%A0/"/>
    <url>/2021/09/13/%E5%BA%8F%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="关于这门课程"><a href="#关于这门课程" class="headerlink" title="关于这门课程"></a>关于这门课程</h1><p>数据结构作为计算机专业的基础专业课程，在学习中有着举足轻重的作用；而如果未来有考研的计划的话，这会是一个很重要的课程。</p><a id="more"></a><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>未来我会跟着课程的进度，对对应章节进行归纳整理出相对应的文章，把握课程的中心思想并为期末复习做好充足准备。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github入门教程</title>
    <link href="/2021/03/09/Github%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/03/09/Github%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这又是我开的另一个大坑的内容，这部分主要是想要讲一下GitHub的基本使用方法、一些常用的指令以及一个我正在采用的同步的一个流程。</p><h2 id="关于GitHub"><a href="#关于GitHub" class="headerlink" title="关于GitHub"></a>关于GitHub</h2><p>GitHub是全球最大的同性交流网站，在上面你几乎能找到你想要的一切内容，而且越来越多人和组织加入到开源的大家庭中这是一件好事。我也是很早以前就接触到了开源的世界，大家在一起交流分享知识增进自己的代码水平，让自己不断的成长。</p><h3 id="进入社区前你要做好的准备"><a href="#进入社区前你要做好的准备" class="headerlink" title="进入社区前你要做好的准备"></a>进入社区前你要做好的准备</h3><p>首先就是一个GitHub的账号，当然如今市面上有很多的开源社区都可以选择，技术和实现的过程几乎是一样的，这里我以我最常用的GitHub为例子来个大家讲解。账号可以在GitHub首页直接注册，目前来说裸连的话也是没有问题的。但是有些时候也会抽风，所以最好准备一个梯子以防不时之需。</p><p>注册完账号之后便是配置在本地环境，直接在终端中输入以下指令</p><p><code>ssh-keygen -C &quot;email adress&quot; -t rsa</code></p><p>这条指令会在你的用户路径下生成一个./ssh的文件夹，进入之后你会发现有两个文件，id_rsa这个文件是私钥（保存好），另一个id_rsa.pub这个是你的公钥。</p><p>之后进入GitHub的个人设置页面中<code>SSH and GPG keys</code>选项中将你的公钥复制进去（是公钥里面的数据，记事本打开即可），完成之后点击add SSH key。</p><p>这样你的配置就完成了。</p><h2 id="关于指令的用法"><a href="#关于指令的用法" class="headerlink" title="关于指令的用法"></a>关于指令的用法</h2><p>在本地的环境配置好了以后    </p><p><a href="https://www.notion.so/d4a976e09955401fbf818fb9dc29a981">常用指令</a></p><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新的文件夹，打开，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>执行语句将他人的仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> /path/to/repository<br></code></pre></td></tr></table></figure><p>如果是远程服务器上的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> username@host:/path/to/repository<br></code></pre></td></tr></table></figure><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>本地的仓库被GitHub用三部分进行维护，并加以三颗“树”状结构进行维护。</p><p>工作目录   是你仓库中实际存储的内容</p><p>暂存区（Index）   在你改动工作目录后，将你的操作暂时存储在该区域</p><p>HEAD     他指向自己的最后一次操作</p><h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>可以提出更改（将他们添加到暂存区中）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;filename&gt;<br>git add *<br></code></pre></td></tr></table></figure><p>使用指令将实际的更改提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;代码提交信息&quot;</span><br></code></pre></td></tr></table></figure><p>之后你的改动就被提交到了HEAD，但是还没有推送到远程仓库</p><h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>执行语句，将你的改动从HEAD中推送到远端仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><p>上方语句实例中，将HEAD提交到master分支中，也可提交到其他分支中。</p><p>如果没有克隆现有仓库，而且你还想将自己的仓库同步到某个服务器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;server&gt;<br></code></pre></td></tr></table></figure><p>这样就可以将自己的仓库同步上去了</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>在开发的时候是在默认的主支上进行的，你可以通过一定的指令操作同步到其他分支，最后开发结束之后合并在一起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature_x  //创建一个feature_x的分支，并切换过去<br>git checkout mastr         //切换到主分支<br>git branch -d feature_x    //将feature_x分支删除<br>git push origin &lt;branch&gt;   //除非将分支推送到远程仓库，不然别人无法访问<br></code></pre></td></tr></table></figure><h2 id="更新合并"><a href="#更新合并" class="headerlink" title="更新合并"></a>更新合并</h2><p>更新本地仓库至线上最新改动版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>以用来在自己的工作目录中 <em>获取(fetch)</em> 并 <em>合并(merge)  远端的改动</em></p><p>如果要合并其他分支到自己当前分支上时，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>在这两种情况下，git都会尝试自动合并改动。有一定的几率会出现 冲突(conflicts) 。这时候需要自己去手动修改某些文件，使得修改完成之后，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>将修改的内容标记为合并成功</p><p>在合并之前，可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff &lt;source_branch&gt;&lt;target_branch&gt;<br></code></pre></td></tr></table></figure><p>来看一下修改前后文件的差别在哪里</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>为软件发布创建标签是推荐的，在之前的软件开发过程中，这个理念就有所体现，在SVN中也有。</p><p>可以执行以下命令创建一个叫做1.0.0的标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag 1.0.0 1b2e1d63ff<br></code></pre></td></tr></table></figure><p>后面的 1b2e1d63ff 是你想提交ID的前十位字符，可以使用 git log 获取提交ID</p><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>如果想要了解一个本地仓库的历史记录，可以直接执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>同时也可以添加一些参数，来获取一些自己想要的特定消息，只看某一人的提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --author=bob<br></code></pre></td></tr></table></figure><p>一个压缩后的每一条提交记录只占一行的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=oneline<br></code></pre></td></tr></table></figure><p>或者你想通过ASCII艺术的树形结构来展示所有的分支，每个分支都标示了他的名字和标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph --oneline --decorate --all<br></code></pre></td></tr></table></figure><p>看看那些文件发生了变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --name-status<br></code></pre></td></tr></table></figure><p>这些只是你可以使用的一小部分参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><p>假如操作发生失误，可以使用如下的命令替换掉本地改动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --&lt;filename&gt;<br></code></pre></td></tr></table></figure><p>此命令可以将HEAD中的最新内容替换掉你的工作目录中的文件。已经添加到暂存区的改动以及新文件都不会收到影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br>git reset --hard oringin/master<br></code></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你的本地主分支指向它</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>构建自己的学习环境</title>
    <link href="/2021/02/13/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/02/13/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>一直觉得自己的学习环境是十分混乱的，<a id="more"></a>而且学习的目标也是杂乱的，不能很轻易的就看出自己的学习的需求，所以一套合理的学习分工是很有必要的，充分利用自己周未的资源同时也提高自己的学习效率。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我的主要的设备是两台笔记本（win+mac环境）加上一台ipad。平时上课和课后的笔记练习等等都是在ipad上完成的，这样大大方便了我的日常学习，在课堂上也可以很快的记录笔记，只是课后的整理并不是很有效率。同时两台电脑的环境可以很好的互相弥补之间的差距，这样的话就算是需要用到win环境的时候也有必要的准备。</p><h2 id="如何更加充分的利用自己的ipad"><a href="#如何更加充分的利用自己的ipad" class="headerlink" title="如何更加充分的利用自己的ipad"></a>如何更加充分的利用自己的ipad</h2><p>  我很担心自己买回来ipad之后是“买前生产力，买后爱奇艺”的这种情况，但是事实并不是这样的，第一个学期下来，我还是坚持的挺好的，比较少的游戏时间和较较长的学习时间。</p><p>  那么下学期，我想让我的学习更具有效率一点，所以我就要准备好一明确的分工，文献的整理可以在整理好后全平台查询。</p><p>  一节课开始前我会准备提前先预习下一节课的内容，同时，上课时gn会很好的帮助我记录一节课的内容，其实就算是错过了也有len可以帮助我及时的把黑板的内容记录下来。</p><h2 id="暂时想到这么多，下学期开学之后会再更新的"><a href="#暂时想到这么多，下学期开学之后会再更新的" class="headerlink" title="暂时想到这么多，下学期开学之后会再更新的"></a>暂时想到这么多，下学期开学之后会再更新的</h2>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境下安装conda并配置环境</title>
    <link href="/2021/02/09/Mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85conda%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/02/09/Mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85conda%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>  从Linux环境到Windows环境再到如今Mac环境下，<a id="more"></a>python的环境和一些常用环境的配置都挺让人头大的，正巧最近了解到conda环境可以很方便的配置一些常用的环境，以及一些python的包管理也很方便，所以这里我便简单的记录一下我的安装历程，把出现的一些问题罗列一下，希望能帮助到别人不踩相同的坑。</p><h1 id="安装Anacoda-Miniconda"><a href="#安装Anacoda-Miniconda" class="headerlink" title="安装Anacoda/Miniconda"></a>安装Anacoda/Miniconda</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>根据自己使用的环境的不同，可以在清华大学开源镜像站中找到合适的安装包，</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/#">快速链接</a> 在右侧获取下载链接 —–&gt; 常用软件 ——&gt; 选择anaconda/miniconda</p><p>两者的主要区别就是，anaconda包含了所有的所需要的内容，而miniconda是一个轻量级的替代，只包含了python和conda从而体积也小了很多。</p><p>下载之后在终端中，使用指令<code>bash xxxxx.sh</code>进行安装，按回车后会出现大段的安装说明，直接顺着流程进行就可以顺利安装了</p><h2 id="配置conda环境"><a href="#配置conda环境" class="headerlink" title="配置conda环境"></a>配置conda环境</h2><p>安装完成之后，使用<code>vim ~/.condarc</code>编辑这个文件，便可以修改里面的内容，根据清华大学开源镜像站中的帮助手册，你可以很快的配置完成这一步。</p><h2 id="出现的情况"><a href="#出现的情况" class="headerlink" title="出现的情况"></a>出现的情况</h2><p>每次打开终端自动进入conda的虚拟环境</p><p>解决方法：</p><p>​            在.condarc中配置    auto_activate_base  为   false就是关闭</p><p>​            如果需要打开 conda config –set auto_activate_base true</p><p>​            就可以重新打开</p><h1 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h1><p>使用指令 <code>conda create -n env_name</code>可以创建一个名为env_name的环境</p><p>之后进入环境之后再运行 <code>conda install pkg_name</code>安装你所需要的包</p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>1.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">Linking</span> packages … <br><span class="hljs-attribute">PaddingError</span>: Placeholder of length ‘<span class="hljs-number">30</span>’ too short in package qt-<span class="hljs-number">5</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>-vc<span class="hljs-number">14</span>_<span class="hljs-number">0</span>.% <br><span class="hljs-attribute">The</span> package must be rebuilt with conda-build &gt; <span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<br><br></code></pre></td></tr></table></figure><p>方案：</p><p><code>conda update conda</code> ,然后<code>conda update –all </code>下，可以解决大部分问题</p><p>参考阅读：https:<em>//blog.csdn.net/xxzhangx/article/details/54379255?locationNum=3&amp;fps=1</em></p><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><h2 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h2><p><code>conda deactivate</code></p><h2 id="查看所有虚拟环境"><a href="#查看所有虚拟环境" class="headerlink" title="查看所有虚拟环境"></a>查看所有虚拟环境</h2><p><code>conda info -e</code></p><h2 id="查看安装的包"><a href="#查看安装的包" class="headerlink" title="查看安装的包"></a>查看安装的包</h2><p><code>conda list</code></p><h2 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h2><p><code>conda remove -n env_name --all</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青蛙过河题解</title>
    <link href="/2021/02/01/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/02/01/%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>我会以图片的形式简单形容一下思路，能够更好的理解。</p><a id="more"></a><p><img src="/Users/l_collection/blog/source/img/img001.jpeg"></p><p>可以很明显的推导出，整个递归的边界就是<strong>tiao(0,y) = y+1 ** ，而左右两岸之间没多一根柱子的话就会使他的数量翻一倍，</strong>tiao(x,y) = tiao(x-1,y)*2** 这个公式是推导出来的另一种形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tiao</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> y+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*tiao(x<span class="hljs-number">-1</span>,y);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> x,y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>            <span class="hljs-built_in">cout</span> &lt;&lt; tiao(x,y) &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>这个题目整体还是以道很简单的递归的题目，同时也是看自己的数学上的推导能力，接下来还是要自己动手多推导，同时也要提高自己的代码实现能力，又很多的题目都是有想法的但是最后还是没有足够的代码基础进行实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SDUT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/10/hello-world/"/>
    <url>/2021/01/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
